{"meta":{"title":"Cys's blog","subtitle":null,"description":null,"author":"Cys","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About Me","date":"2019-05-23T08:42:04.000Z","updated":"2019-09-03T10:14:02.740Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"CybOther ExperienceFrom July 27th to August 4th, I went on a field research to a village called Pengkou in the county of Liacheng，which is in the west of Fujian province，with professor Chen Zhibiao, a prestigious experienced scholar in soil erosion mitigation and ecosystem restoration who has took part in national projects about the recovering of the environment in west Fujian since more than twenty years ago, also one of the first researchers to work on treatment of soil erosion nationwide, and his four graduates from the institute of geography of the Fujian Normal University. The main purpose of the research is to collect soil samples containing rare earth. There are two groups of soil samples to collect: one group is excavated from a hill which had experienced rare earth mining several years ago, while the other group is excavated from another hill next to the previous one which has not involved in rare earth mining. Therefore, what we collect will help researchers to form a deeper and more overall understanding about the impact of rare earth mining on the environment by processing those samples with scientific approaches like cooking them in acidic environment and high temperature to extract rare earth elements and comparing the results of samples from different areas."}],"posts":[{"title":"Other Experience","slug":"Other-Experience","date":"2019-09-03T10:05:40.000Z","updated":"2019-09-03T10:09:10.525Z","comments":true,"path":"2019/09/03/Other-Experience/","link":"","permalink":"http://yoursite.com/2019/09/03/Other-Experience/","excerpt":"","text":"From July 27th to August 4th, I went on a field research to a village called Pengkou in the county of Liacheng，which is in the west of Fujian province，with professor Chen Zhibiao, a prestigious experienced scholar in soil erosion mitigation and ecosystem restoration who has took part in national projects about the recovering of the environment in west Fujian since more than twenty years ago, also one of the first researchers to work on treatment of soil erosion nationwide, and his four graduates from the institute of geography of the Fujian Normal University. The main purpose of the research is to collect soil samples containing rare earth. There are two groups of soil samples to collect: one group is excavated from a hill which had experienced rare earth mining several years ago, while the other group is excavated from another hill next to the previous one which has not involved in rare earth mining. Therefore, what we collect will help researchers to form a deeper and more overall understanding about the impact of rare earth mining on the environment by processing those samples with scientific approaches like cooking them in acidic environment and high temperature to extract rare earth elements and comparing the results of samples from different areas.","categories":[],"tags":[]},{"title":"2.3 决策树模型使用","slug":"2-3-决策树模型使用","date":"2019-05-23T07:56:09.000Z","updated":"2019-05-23T08:04:47.079Z","comments":true,"path":"2019/05/23/2-3-决策树模型使用/","link":"","permalink":"http://yoursite.com/2019/05/23/2-3-决策树模型使用/","excerpt":"","text":"数据集划分留出法（Hold-out）我们现在用一个简单的例子来看看留出法是如何运作的。 123456789101112131415161718192021222324from sklearn.model_selection import train_test_split# 简单的数据X=[[1,2,3,4], [11,12,13,14], [21,22,23,24], [31,32,33,34], [41,42,43,44], [51,52,53,54], [61,62,63,64], [71,72,73,74]]y=[1,1,0,0,1,1,0,0]# 使用留出法划分数据集 - test_size:样本占比 random_state:随机数生成器X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.5, random_state=0) # X的划分情形print(\"X_train=\", X_train)print(\"X_test=\", X_test)# Y的划分情形print(\"y_train=\", y_train)print(\"y_test=\", y_test) X_train= [[31, 32, 33, 34], [1, 2, 3, 4], [51, 52, 53, 54], [41, 42, 43, 44]] X_test= [[61, 62, 63, 64], [21, 22, 23, 24], [11, 12, 13, 14], [71, 72, 73, 74]] y_train= [0, 1, 1, 1] y_test= [0, 0, 1, 0] 波士顿房价案例看完留出法的运作方式后，现在让我们使用上节课的波士顿房价例子（boston_price.csv），观察使用留出法划分的数据拟合决策树模型后的预测效果。 首先，让我们再次观察数据集的内容。 123import pandas as pdprice_data = pd.read_csv('boston_price.csv')price_data.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }RMLSTATPTRATIOMDEV06.5754.9815.3504000.016.4219.1417.8453600.027.1854.0317.8728700.036.9982.9418.7701400.047.1475.3318.7760200.0 将房间数、低社会阶层比例和师生比订为X，房价中位数则是Y。 12X = price_data[['RM','LSTAT','PTRATIO']]Y = price_data['MDEV'] 和之前不同的，现在我们针对数据集，使用留出法做划分的动作。 1X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.5, random_state=0) 最后，将X_train和y_train放进决策树模型进行拟合，并用X_test和y_test去评估模型预测的准确度。 12345from sklearn.tree import DecisionTreeRegressordt = DecisionTreeRegressor(max_depth=4)dt.fit(X_train,y_train)dt.score(X_test, y_test) 0.7601306276189493 母亲数据集分析导入母亲情况数据集(mom_data_revised.csv)，并输出前5行。 123456from sklearn.model_selection import train_test_splitimport pandas as pdimport numpy as npmom_data = pd.read_csv('mom_data_revised.csv', index_col=0)mom_data.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }HIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 20140989.0631134556743241220.0121475.01332202095978240202.0202328.0142240509829221774.046313113.0731115781214360610.01141580.0531326408227447115.031 提取数据集：‘REGION 1979’和’TOTAL NET FAMILY INCOME 1979’作为X，’TOTAL NET FAMILY INCOME 2014’作为Y 12X = mom_data[['TOTAL NET FAMILY INCOME 1979','REGION 1979']]Y = mom_data['TOTAL NET FAMILY INCOME 2014'] 划分训练集和测试集 12# 划分数据集X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.25, random_state=0) 使用训练集进行模型构建和拟合。 1234567from sklearn.tree import DecisionTreeRegressor# 构建模型：参数可以调整，详细意义和影响会在下节课揭晓dt = DecisionTreeRegressor(max_depth=2)# 进行模型拟合dt.fit(X_train, y_train) DecisionTreeRegressor(criterion=&apos;mse&apos;, max_depth=2, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort=False, random_state=None, splitter=&apos;best&apos;) 使用测试集评判模型优劣 12# 评估准确度dt.score(X_test, y_test) 0.6651016744604565 随堂练习 1提取母亲数据集中的数据：‘HIGHEST GRADE COMPLETED’和’TOTAL IQ SCORE’作为X，’TOTAL NET FAMILY INCOME 2014’作为Y 123456# grader format### BEGIN SOLUTIONX = mom_data[['HIGHEST GRADE COMPLETED','TOTAL IQ SCORE']]Y = mom_data['TOTAL NET FAMILY INCOME 2014']### END SOLUTION 随堂练习 2将数据集分为训练集以及测试集(test_size=0.3) 12345# grader format### BEGIN SOLUTIONX_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.3, random_state=0)### END SOLUTION 随堂练习 3构建决策树回归树(max_depth=2)进行拟合并打印测试集的score 1234567# grader format### BEGIN SOLUTIONdt = DecisionTreeRegressor(max_depth=2)dt.fit(X_train, y_train)dt.score(X_test, y_test)### END SOLUTION 0.7587765615967225 交叉验证法（Cross Validation）for简单例子以此打印’Python’五个字母 12for i in 'Python': print(i) P y t h o n 我们可以使用循环语句帮助我们反复执行程序，例如，我们可以使用for语句帮我们叠加数字，从1加到100。 123456789# 总和的预设值s=0# 叠加数字for i in range(1,101): s = s + i # 最终的总和print(s) 5050 for语句不止可以在数字中遍历，也可以对多变量（元素对）进行循环遍历。 123456# 2-d listlist_test = [[1,2],[3,4],[5,6],[7,8]]# 一次同时循环两个变量：i, jfor i, j in list_test: print('i = &#123;0&#125;, j = &#123;1&#125;'.format(i, j)) i = 1, j = 2 i = 3, j = 4 i = 5, j = 6 i = 7, j = 8 for语句也可以多层进行——使用for语句实现九九乘法表就是两层for循环语句嵌套的实例。 12345678910# 前面数字for i in range(1, 10): # 后面数字 for j in range(1, i+1): # 两者相乘 d = i * j print('%d*%d=%-2d' % (i, j, d), end = ' ' ) # 每一个i结束就打印一次 print() 1*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 K-Fold我们看下k-Fold是如何运行的 123456789101112131415from sklearn.model_selection import KFold# 简单的数据X=np.array([[1,2,3,4], [11,12,13,14], [21,22,23,24], [31,32,33,34], [41,42,43,44], [51,52,53,54], [61,62,63,64], [71,72,73,74]])y=np.array([1,1,0,0,1,1,0,0])#将折数设置为4KF = KFold(n_splits=4,shuffle=False) k-fold后的结果 12345678for train_index, test_index in KF.split(X,y): print('Train Dataset') print(X[train_index]) print(y[train_index]) print('Test Dataset') print(X[test_index]) print(y[test_index]) print('--------') Train Dataset [[21 22 23 24] [31 32 33 34] [41 42 43 44] [51 52 53 54] [61 62 63 64] [71 72 73 74]] [0 0 1 1 0 0] Test Dataset [[ 1 2 3 4] [11 12 13 14]] [1 1] -------- Train Dataset [[ 1 2 3 4] [11 12 13 14] [41 42 43 44] [51 52 53 54] [61 62 63 64] [71 72 73 74]] [1 1 1 1 0 0] Test Dataset [[21 22 23 24] [31 32 33 34]] [0 0] -------- Train Dataset [[ 1 2 3 4] [11 12 13 14] [21 22 23 24] [31 32 33 34] [61 62 63 64] [71 72 73 74]] [1 1 0 0 0 0] Test Dataset [[41 42 43 44] [51 52 53 54]] [1 1] -------- Train Dataset [[ 1 2 3 4] [11 12 13 14] [21 22 23 24] [31 32 33 34] [41 42 43 44] [51 52 53 54]] [1 1 0 0 1 1] Test Dataset [[61 62 63 64] [71 72 73 74]] [0 0] -------- K-折（K-Fold）：波士顿房价案例我们再次使用波士顿房价的案例。这一次，我们将数据集使用k-折方式划分。首先，先让我们观察一下经过k-折方式划分的训练集和测试集分别长什么样子。 1234567from sklearn.model_selection import KFoldX = price_data[['RM','LSTAT','PTRATIO']]Y = price_data['MDEV']#将折数设置为5，不进行随机采样操作KF = KFold(n_splits=5,shuffle=False) 接着，我们将划分好的数据集分别放进模型中进行拟合。 1234567891011121314151617181920from sklearn.tree import DecisionTreeRegressor# 建构模型dt_price_kfold = DecisionTreeRegressor(max_depth=6)# 最终准确度的预设值price_score = 0k_fold_price = []# 使用for语句将划分出的5组数据索引代入for train_index, test_index in KF.split(X,Y): # 使用训练集拟合 dt_price_kfold.fit(X.iloc[train_index], Y[train_index]) # 使用测试集评估，将每一次评估的数值叠加 price_score += dt_price_kfold.score(X.iloc[test_index], Y.iloc[test_index]) # 将每一次评估的结果存储 k_fold_price.append(dt_price_kfold.score(X.iloc[test_index],Y.iloc[test_index]))# 最终看5次评估结果的平均数print (price_score / 5) 0.5450223138431061 观察看看每一次划分出来的数据集拟合出的模型预测结果如何。 12345678import numpy as npimport matplotlib.pyplot as pltplt.plot([k_fold for k_fold in range(1,6)], k_fold_price, linewidth=2)plt.title(\"Numbers----Score\")plt.xlabel('Numbers')plt.ylabel('Score')plt.xticks(np.arange(1, 6, step=1))plt.show() &lt;Figure size 640x480 with 1 Axes&gt; 随堂练习 4提取mom_data中的’TOTAL NET FAMILY INCOME 1979’,’REGION 1979’作为X，’TOTAL NET FAMILY INCOME 2014’作为Y 123456# grader format### BEGIN SOLUTIONX = mom_data[['TOTAL NET FAMILY INCOME 1979','REGION 1979']]Y = mom_data['TOTAL NET FAMILY INCOME 2014']### END SOLUTION 随堂练习 5 运用k-fold进行数据切分(KF = KFold(n_splits=5,shuffle=False)) 构建决策树回归模型(DecisionTreeRegressor()) 123456# grader format### BEGIN SOLUTIONKF = KFold(n_splits=5,shuffle=False)dt_kfold = DecisionTreeRegressor(max_depth=2)### END SOLUTION 随堂练习 6针对k-fold后的数据集进行决策树回归模型的预测，打印出模型score的平均值。 1234567891011# grader formatincome_score = 0### BEGIN SOLUTIONfor train_index, test_index in KF.split(X, Y): dt_kfold.fit(X.iloc[train_index], Y.iloc[train_index]) income_score += dt_kfold.score(X.iloc[test_index], Y.iloc[test_index])# 最终看5次评估结果的平均数print(income_score / 5)### END SOLUTION 0.6646540979627125 课后练习 1用for循环计算20的阶乘(20！) 12345678910# grader format### BEGIN SOLUTIONresult = 1for i in range(1,21): result = result*i print(result)### END SOLUTION 2432902008176640000 课后练习 2导入综合数据集(mom_student_data.csv)。提取’EMPLOYMENT STATUS 2014’和’TOTAL NET FAMILY INCOME 2014’作为X，’piatmath_percent’作为Y。 1234567# grader format### BEGIN SOLUTIONdf = pd.read_csv('mom_student_data.csv', index_col=0)X = df[['EMPLOYMENT STATUS 2014','TOTAL NET FAMILY INCOME 2014']]Y = df['Score']### END SOLUTION 课后练习 3运用train_test_split切分训练和测试数据集(test_size=0.25)，然后构建决策回归树，然后打印出测试数据集的score。 12345678# grader format### BEGIN SOLUTIONX_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.25, random_state=0)dt = DecisionTreeRegressor(max_depth=2)dt.fit(X_train, y_train)dt.score(X_test, y_test)### END SOLUTION 0.4578224279233941 课后练习 4运用KFold切分训练和测试数据集(n_splits=5)，然后构建决策回归树，然后打印出测试数据集的平均score。 1234567891011121314# grader format### BEGIN SOLUTIONKF = KFold(n_splits=5,shuffle=False)score = 0for train_index, test_index in KF.split(X, Y): dt_kfold.fit(X.iloc[train_index], Y.iloc[train_index]) score += dt_kfold.score(X.iloc[test_index], Y.iloc[test_index])# 最终看5次评估结果的平均数print(score / 5)### END SOLUTION 0.4488234535632075 12 12","categories":[],"tags":[]},{"title":"2.4 决策树模型评估","slug":"2-4-决策树模型评估","date":"2019-05-23T07:50:42.000Z","updated":"2019-05-23T08:22:06.512Z","comments":true,"path":"2019/05/23/2-4-决策树模型评估/","link":"","permalink":"http://yoursite.com/2019/05/23/2-4-决策树模型评估/","excerpt":"","text":"决策树模型评估$R^2$和均方根误差（score &amp; RMSE）波士顿房价案例我们引入更多变量来对波士顿的房价进行预测。变量解释如下表所示： 变量 解释 CRIM 城镇人均犯罪率 ZN 住宅用地超过25000的比例 INDUS 城镇非零售商用土地的比例 CHAS 查理斯河变量 NOX 一氧化氮浓度 RM 住宅平均房间数 AGE 1940 年之前建成的自用房屋比例 DIS 到波士顿五个中心区域的加权距离 RAD 辐射性公路的接近指数 TAX 每10000美元的全值财产税率 PTRATIO 城镇师生比例 B 城镇中黑人的比例 LSTAT 人口中地位低下者的比例 MEDV 自住房的平均房价 同样的，我们首先导入数据集（boston_price_full.csv），并观察数据集的样貌。 123456from sklearn.datasets import load_bostonimport pandas as pdimport numpy as npprice_data = pd.read_csv('boston_price_full.csv')price_data.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }CRIMZNINDUSCHASNOXRMAGEDISRADTAXPTRATIOBLSTATMEDV00.0063218.02.3100.5386.57565.24.0900129615.3396.904.9824.010.027310.07.0700.4696.42178.94.9671224217.8396.909.1421.620.027290.07.0700.4697.18561.14.9671224217.8392.834.0334.730.032370.02.1800.4586.99845.86.0622322218.7394.632.9433.440.069050.02.1800.4587.14754.26.0622322218.7396.905.3336.2 接着，我们对数据集使用留出法进行划分。其中75%作为训练集，25%作为测试集。 12345678from sklearn.model_selection import train_test_split# 提取X和YX = price_data.loc[:, price_data.columns != 'MEDV']Y = price_data['MEDV']# 划分数据集X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.25, random_state=0) 构建回归决策树模型，使用训练集拟合，并用测试集计算其$R^2$(score)。 12345678910from sklearn.tree import DecisionTreeRegressor# 构建模型dt = DecisionTreeRegressor(max_depth=2)# 进行拟合dt.fit(X_train, y_train)# 评估模型（计算score）dt.score(X_test, y_test) 0.5920940318375818 使用X_test预测y（y_predict）。使用y_test和y_predict可以计算均方根误差(RMSE)。 1234567891011from sklearn.metrics import mean_squared_error# 预测yy_predict = dt.predict(X_test)# 计算均方误差Dec_mse = mean_squared_error(y_test, y_predict)# 计算均方根误差Dec_rmse = np.sqrt(Dec_mse)Dec_rmse 5.772825650421667 随堂练习 1导入母亲和孩子信息综合数据集(mom_student_data.csv)，命名为mom_student_data,并输出前5行。 1234567# grader formatfrom sklearn.model_selection import train_test_split### BEGIN SOLUTIONmom_student_data = pd.read_csv('mom_student_data.csv', index_col=0)mom_student_data.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 20140931197946989.0631134556743241220.0121704321198147475.01332202095978240202.0202879712199025328.0142240509829221774.046330402119822813113.0731115781214360610.01141137312001781580.0531326408227447115.031 随堂练习 2删除mom_student_data中的’PID’和’SAMPLE IDENTIFICATION CODE’，重新命名为mom_student_revised并输出前5行。 123456# grader format### BEGIN SOLUTIONmom_student_revised = mom_student_data.drop(['PID','SAMPLE IDENTIFICATION CODE'], axis=1)mom_student_revised.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }childracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 2014031197946989.031134556743241220.012121198147475.032202095978240202.020212199025328.02240509829221774.04632119822813113.031115781214360610.0114312001781580.031326408227447115.031 随堂练习 3从mom_student_revised数据集中Score作为y，其余数据为X，用train_test_split()切分训练集和测试集(test_size=0.25) 1234567# grader format### BEGIN SOLUTIONX = mom_student_revised.loc[:, mom_student_revised.columns != 'Score']y = mom_student_revised['Score']X_train, X_test, y_train, y_test = train_test_split(X, y,test_size=0.25, random_state=0)### END SOLUTION 随堂练习 4建构并训练（拟合）模型。使用test数据(X_test以及y_test)它们计算模型的预测结果$R^2$。 12345678910111213# grader formatfrom sklearn.tree import DecisionTreeRegressor### BEGIN SOLUTION# 建构模型dt = DecisionTreeRegressor(max_depth=2)# 训练模型dt.fit(X_train, y_train)# 计算R^2dt.score(X_test,y_test)### END SOLUTION 0.5936128595866402 特征的选择在选择用来预测的特征时，我们会先查看特征（X候选）和预测目标（Y）之间的相关性。一般来说，当它们之间具有较高的相关性时，我们较可能把该特征放进X中。这样可以在不大幅降低预测结果的基础上提升运算速度。现在，让我们来查看波士顿房价数据集中各个特征之间的相关性。一个较为清楚的观察方式是画出热图（heatmap）。 12345678910111213import matplotlib.pyplot as pltimport seaborn as snsimport pandas as pd# 计算相关性price_data_corr = price_data.corr()# 画出热图sns.heatmap(price_data_corr, cmap=\"PiYG\")# 将字体进行旋转plt.xticks(rotation=45) plt.show() 观察heatmap，我们可以找到颜色比较深（相关性高）的特征，并将它们视为X。 12X = price_data[['INDUS', 'RM', 'TAX', 'PTRATIO', 'LSTAT']]Y = price_data['MEDV'] 同样的，我们对数据集做划分——其中75%作为训练集，25%作为测试集。 1X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.25, random_state=0) 接着，构建模型，拟合（训练）并评估（测试）。 12345from sklearn.tree import DecisionTreeRegressordt = DecisionTreeRegressor(max_depth=2)dt.fit(X_train, Y_train)dt.score(X_test, Y_test) 0.592094031837582 随堂练习 5针对石油数据集画出所有特征的热图（heatmap）。 12345678910111213# grader format### BEGIN SOLUTION# 计算相关性revised_data_corr = mom_student_revised.corr()# 画出热图sns.heatmap(revised_data_corr, center = 0, cmap=\"YlGnBu\")### END SOLUTION#plt.xticks(rotation=45) # 将字体进行旋转plt.yticks(rotation=360)plt.show() 随堂练习 6根据热图，我们提取与学生成绩指数(Score), 相关性高的特征(‘HIGHEST GRADE COMPLETED’, ‘TOTAL IQ SCORE’,’TOTAL NET FAMILY INCOME 1979’, ‘TOTAL NET FAMILY INCOME 2014’)设为X。数据中取得训练集和测试集。其中75%作为训练集，25%作为测试集。 123456789# grader format### BEGIN SOLUTIONX = mom_student_revised[['HIGHEST GRADE COMPLETED', 'TOTAL IQ SCORE', 'TOTAL NET FAMILY INCOME 1979', 'TOTAL NET FAMILY INCOME 2014']]y = mom_student_revised['Score']X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25,random_state=0)### END SOLUTION 随堂练习 7构建决策回归树模型(dt = DecisionTreeRegressor(max_depth=2))。使用训练数据集训练模型，并通过测试数据集预测模型的R2。 1234567891011# grader formatfrom sklearn.tree import DecisionTreeRegressor### BEGIN SOLUTION# 建构模型dt = DecisionTreeRegressor(max_depth=2)# 训练模型dt.fit(X_train, y_train)# 计算R^2dt.score(X_test, y_test)### END SOLUTION 0.5416805060255403 参数的选择构建模型的时候，我们总是写着max_depth=N，到底这个max_depth如何影响模型？要怎么选择呢？ 这里，我们使用price_data数据集。将’MEDV’作为Y，’INDUS’, ‘RM’, ‘TAX’, ‘PTRATIO’, ‘LSTAT’作为X。直接划分数据集，其中75%作为训练集，25%作为测试集。 1234X = price_data[['INDUS', 'RM', 'TAX', 'PTRATIO', 'LSTAT']]Y = price_data['MEDV']X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.25, random_state=0) 使用for语句构建多个模型，max_depth设定从1到16，并记录这些模型分别使用训练集和测试集计算出的$R^2$。 12345678910111213141516# 预留空间存储scoretrain_score = []test_score = []# 设定max_depth的范围max_depth = range(1,16)# for语句将所有max_depth遍历for i in max_depth: # 构建模型 dt = DecisionTreeRegressor(max_depth=i) # 训练模型 dt.fit(X_train,y_train) # 分别使用训练集和测试集计算score train_score.append(dt.score(X_train, y_train)) test_score.append(dt.score(X_test, y_test)) 将刚才存储的“由训练集和测试集计算出的$R^2$”以数据可视化的方式展示。 123456789101112import matplotlib.pyplot as plt# 训练集计算的score：蓝色线plt.plot(max_depth, train_score, linewidth=2)# 测试集计算的score：橘色线plt.plot(max_depth, test_score, linewidth=2)plt.title(\"Score with different depth\")plt.xlabel('depth')plt.ylabel('score')plt.legend(['Train', 'Test'])plt.show() 随堂练习 8这里，我们使用mom_student_revised数据集。将学业成绩Score作为Y，其余变量作为X。直接划分数据集，其中75%作为训练集，25%作为测试集。 1234567# grader format### BEGIN SOLUTIONX = mom_student_revised.loc[:, mom_student_revised.columns != 'Score']y = mom_student_revised['Score']X_train, X_test, y_train, y_test = train_test_split(X, y,test_size=0.25, random_state=0)### END SOLUTION 随堂练习 9接着，使用for语句构建多个模型，max_depth设定从1到16，并记录这些模型分别使用训练集和测试集计算出的$R^2$。 1234567891011121314151617181920# grader format# 预留空间存储scoretrain_score = []test_score = []# 设定max_depth的范围max_depth = range(1,16)### BEGIN SOLUTION# for语句将所有max_depth遍历for i in max_depth: # 构建模型 dt = DecisionTreeRegressor(max_depth=i) # 训练模型 dt.fit(X_train,y_train) # 分别使用训练集和测试集计算score train_score.append(dt.score(X_train, y_train)) test_score.append(dt.score(X_test, y_test)) ### END SOLUTION 随堂练习 10接着，将刚才存储的“由训练集和测试集计算出的$R^2$”以数据可视化的方式展示。 123456789101112131415# grader formatimport matplotlib.pyplot as plt### BEGIN SOLUTION# 训练集计算的score：蓝色线plt.plot(max_depth, train_score, linewidth=2)# 测试集计算的score：橘色线plt.plot(max_depth, test_score, linewidth=2)### END SOLUTIONplt.title(\"Score with different depth\")plt.xlabel('depth')plt.ylabel('score')plt.legend(['Train', 'Test'])plt.show() 课后练习 1导入学生母亲综合数据集(mom_student_data.csv)，删除PID和SAMPLE IDENTIFICATION CODE并显示前5行。 12345678# grader formatfrom sklearn.model_selection import train_test_split### BEGIN SOLUTIONmom_student_data = pd.read_csv('mom_student_data.csv', index_col=0)mom_student_data = mom_student_data.drop(['PID','SAMPLE IDENTIFICATION CODE'], axis=1)mom_student_data.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }childracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 2014031197946989.031134556743241220.012121198147475.032202095978240202.020212199025328.02240509829221774.04632119822813113.031115781214360610.0114312001781580.031326408227447115.031 课后练习 2观察所有特征之间的相关性。 12345678910111213141516# grader formatimport matplotlib.pyplot as pltimport seaborn as snsimport pandas as pd### BEGIN SOLUTION# 计算相关性data_corr = mom_student_data.corr()# 画出热图，仔细看热图旁边的图示告诉你什么sns.heatmap(data_corr, cmap=\"PiYG\")### END SOLUTION# 将字体进行旋转plt.xticks() plt.show() 课后练习 3提取mom_student_data中的’HIGHEST GRADE COMPLETED’, ‘TOTAL IQ SCORE’, ‘TOTAL NET FAMILY INCOME 1979’, ‘TOTAL NET FAMILY INCOME 2014’,’MARITAL STATUS 1979’,’MARITAL STATUS 2014’作为X，’Score’作为y。 123456789# grader format### BEGIN SOLUTIONX = mom_student_data[['HIGHEST GRADE COMPLETED', 'TOTAL IQ SCORE','MARITAL STATUS 1979','MARITAL STATUS 2014', 'TOTAL NET FAMILY INCOME 1979', 'TOTAL NET FAMILY INCOME 2014']]y = mom_student_data['Score']X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25,random_state=0)### END SOLUTION 课后练习 4记入不同max_depth(1到10)的train和test的score值 12345678910111213141516171819# grader formattrain_score = []test_score = []# 设定max_depth的范围max_depth = range(1,11)### BEGIN SOLUTION# for语句将所有max_depth遍历for i in max_depth: # 构建模型 dt = DecisionTreeRegressor(max_depth=i) # 训练模型 dt.fit(X_train,y_train) # 分别使用训练集和测试集计算score train_score.append(dt.score(X_train, y_train)) test_score.append(dt.score(X_test, y_test)) ### END SOLUTION 课后练习 5将不同max_depth模型的$R^2$画出，观察哪一个数值最合适。 1234567891011121314# grader formatimport matplotlib.pyplot as plt### BEGIN SOLUTION# 训练集计算的score：蓝色线plt.plot(max_depth, train_score, linewidth=2)# 测试集计算的score：橘色线plt.plot(max_depth, test_score, linewidth=2)### END SOLUTIONplt.title(\"Score with different depth\")plt.xlabel('depth')plt.ylabel('score')plt.show() 12","categories":[],"tags":[]},{"title":"2.2 决策树模型简介","slug":"2-2-决策树模型简介","date":"2019-05-23T07:50:13.000Z","updated":"2019-05-23T08:02:47.641Z","comments":true,"path":"2019/05/23/2-2-决策树模型简介/","link":"","permalink":"http://yoursite.com/2019/05/23/2-2-决策树模型简介/","excerpt":"","text":"决策树模型实现现在，我们使用回归决策树来试着预测波士顿的房价。 了解数据集房价受到多种因素影响，而在我们的数据集中，共有三个变量可以使用来对波士顿的房价进行回归预测。变量内容如下： 变量 解释 RM 住所含有的平均房间数 LSTAT 住所所在地区含有底层阶层百分比 PTRATIO 所在地区教师学生比 MDEV 房价中位数 首先，让我们将数据集读取进来。 1234567from sklearn.datasets import load_bostonfrom sklearn.tree import DecisionTreeRegressorimport pandas as pdimport numpy as npprice_data = pd.read_csv('boston_price.csv')price_data.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }RMLSTATPTRATIOMDEV06.5754.9815.3504000.016.4219.1417.8453600.027.1854.0317.8728700.036.9982.9418.7701400.047.1475.3318.7760200.0 为了将问题简单化，我们先单独考虑平均房间数对房价的影响。为此，我们先观察平均房间数的最大值，最小值和平均数。 1234room_num = price_data['RM']#np.max(room_num)#np.min(room_num)np.mean(room_num) 6.240288343558291 现在，让我们比较一下：平均房价大于70万 或 小于等于70万 时，平均房间数的不同 123# 提取平均房价大于70万的数据price_over_70 = price_data[price_data['MDEV'] &gt; 700000]price_over_70.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }RMLSTATPTRATIOMDEV27.1854.0317.8728700.036.9982.9418.7701400.047.1475.3318.7760200.0407.0241.9818.3732900.0557.2494.8117.9743400.0 12# 计算平均房间数np.mean(price_over_70['RM']) 7.441600000000003 123# 提取平均房价小于等于70万的数据price_below_70 = price_data[price_data['MDEV'] &lt;= 700000]price_below_70.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }RMLSTATPTRATIOMDEV06.5754.9815.3504000.016.4219.1417.8453600.056.4305.2118.7602700.066.01212.4315.2480900.076.17219.1515.2569100.0 12# 计算平均房间数np.mean(price_below_70['RM']) 6.133267260579074 随堂练习 1导入石油价格数据集(mom_student_data.csv)，并输出前5行 123456# grader format### BEGIN SOLUTIONmom_student_data = pd.read_csv('mom_student_data.csv', index_col=0)mom_student_data.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 20140931197946989.0631134556743241220.0121704321198147475.01332202095978240202.0202879712199025328.0142240509829221774.046330402119822813113.0731115781214360610.01141137312001781580.0531326408227447115.031 随堂练习 2计算当母亲的HIGHEST GRADE COMPLETED大于16时，孩子的学业成绩(Score)的平均数。 123456# grader format### BEGIN SOLUTIONgrade_over16 = mom_student_data[mom_student_data['HIGHEST GRADE COMPLETED'] &gt; 16]np.mean(grade_over16['Score'])### END SOLUTION 74.24731644482611 随堂练习 3计算当母亲的TOTAL IQ SCORE低于90时，孩子学业成绩(Score)的平均数。 123456# grader format### BEGIN SOLUTIONiq_below90 = mom_student_data[mom_student_data['TOTAL IQ SCORE'] &lt; 90]np.mean(iq_below90['Score'])### END SOLUTION 38.550029486927464 构建简单回归决策树模型我们选择平均房间数（RM）作为X，房价中位数（MDEV）作为Y，来构建回归决策树模型。首先，先将X和Y从数据集中提取出来。 12X = price_data['RM']Y = price_data['MDEV'] 接着，我们先要构建一个决策树模型。然后，将X和Y放入模型中进行拟合。 1234567from sklearn.tree import DecisionTreeRegressor# 建立一个回归树dt = DecisionTreeRegressor(max_depth=4)# 将X,Y放入回归树进行拟合dt.fit(np.array(X).reshape(-1, 1),Y) DecisionTreeRegressor(criterion=&apos;mse&apos;, max_depth=4, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort=False, random_state=None, splitter=&apos;best&apos;) 模型优劣的判断score的含义在之后的课程中会讲解 1dt.score(np.array(X).reshape(-1, 1),Y) 0.6412643869479071 现在，我们可以观察架构出来的模型的预测性能——由原始数据和预测结果的比较图来查看。 12345678910111213141516import matplotlib.pyplot as plt# 排序XX_sort = (X.sort_values()).index# 取得回归树预测出的房价price_predict = dt.predict(np.array(X).reshape(-1,1))# 比较原始数据和预测结果plt.scatter(X, Y, color='red', alpha=0.4)plt.plot(X[X_sort.values], price_predict[X_sort.values], linewidth=2)plt.title(\"Decision Tree Regression\")plt.xlabel('RM')plt.ylabel('MDEV')plt.show() &lt;Figure size 640x480 with 1 Axes&gt; 随堂练习 4我们现在将学业成绩数据集(mom_student_data.csv)中的母亲的智商（TOTAL IQ SCORE）作为X，学生的学业成绩（Score）作为Y，构建回归决策树模型。首先，将X和Y从数据集中提取出来。 123456# grader format### BEGIN SOLUTIONX = mom_student_data['TOTAL IQ SCORE']Y = mom_student_data['Score']### END SOLUTION 随堂练习 5构建一个决策树模型，并将X和Y放入模型中进行拟合。 1234567# grader formatfrom sklearn.tree import DecisionTreeRegressor### BEGIN SOLUTIONdt = DecisionTreeRegressor()dt.fit(np.array(X).reshape(-1, 1),Y)### END SOLUTION DecisionTreeRegressor(criterion=&apos;mse&apos;, max_depth=None, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort=False, random_state=None, splitter=&apos;best&apos;) 随堂练习 6打印出模型的score，以此来判断单变量的决策树模型的优劣 12345# grader format### BEGIN SOLUTIONprint(dt.score(np.array(X).reshape(-1, 1),Y))### END SOLUTION 0.4635799548076138 构建多变量决策树回归模型同样使用波士顿房价数据集（price_data)，我们这次选择房间数（RM）、所在地区教师学生比（PTRATIO）作为X，房价中位数（MDEV）作为Y来构建模型。首先，从数据集中提取X和Y。 123import numpy as npX = np.array(price_data[['RM','PTRATIO']])Y = np.array(price_data['MDEV']) 构建决策树模型并进行拟合。 1234from sklearn.tree import DecisionTreeRegressordt = DecisionTreeRegressor(max_depth=2)dt.fit(X,Y) DecisionTreeRegressor(criterion=&apos;mse&apos;, max_depth=2, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort=False, random_state=None, splitter=&apos;best&apos;) 打印模型的分数 1print(dt.score(X,Y)) 0.6544650201399327 观察架构出来的模型的预测性能。 1234import matplotlib.pyplot as pltprice_data['predict value'] = dt.predict(X)price_data[['MDEV','predict value']].plot()plt.show() 随堂练习 7从数据集中提取X和Y：我们选择母亲的智商分数（TOTAL IQ SCORE）、母亲测试成绩（AFQT）作为X，学生的（piatmath_percent）作为Y。 123456# grader format### BEGIN SOLUTIONX = mom_student_data[['TOTAL IQ SCORE','AFQT']]Y = mom_student_data['Score']### END SOLUTION 随堂练习 8构建决策树回归模型并拟合，打印出模型的Score值 12345678# grader formatfrom sklearn.tree import DecisionTreeRegressor### BEGIN SOLUTIONdt = DecisionTreeRegressor()dt.fit(X,Y)print(dt.score(X,Y))### END SOLUTION 0.7923468112544576 课后练习 1请导入数据集(mom_student_data.csv)并显示前5行。 1234567# grader formatimport numpy as np### BEGIN SOLUTIONmom_student_data = pd.read_csv('mom_student_data.csv', index_col=0)mom_student_data.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 20140931197946989.0631134556743241220.0121704321198147475.01332202095978240202.0202879712199025328.0142240509829221774.046330402119822813113.0731115781214360610.01141137312001781580.0531326408227447115.031 课后练习 2在mom_student_data中提取母亲和小孩都是白人的数据(childrace==3以及RACIAL==3)并命名为white_data。 123456# grader format### BEGIN SOLUTIONwhite_data = mom_student_data[(mom_student_data['childrace'] == 3) &amp; (mom_student_data['RACIAL'] == 3)]### END SOLUTION 课后练习 31.从white_data中提取学生学业成绩(Score)作为X以及2014年家庭年收入(TOTAL NET FAMILY INCOME 2014)作为y。2.构建回归决策树(设置参数max_depth=5,dt = DecisionTreeRegressor(max_depth=5))并打印出模型的准确性(score). 12345678910# grader format### BEGIN SOLUTIONX = white_data['TOTAL NET FAMILY INCOME 2014']y = white_data['Score']dt = DecisionTreeRegressor(max_depth=5)dt.fit(np.array(X).reshape(-1, 1),y)print(dt.score(np.array(X).reshape(-1, 1),y))### END SOLUTION 0.47474817858715057 课后练习 4我们已经提供了待遇测的X_pred,通过之前预测的模型计算预测值并通过折线图进行数据可视化。 12345678# grader formatX_pred = np.arange(X.min(), X.max())### BEGIN SOLUTIONy_pred = dt.predict(np.array(X_pred).reshape(-1, 1))### END SOLUTIONplt.plot(X_pred, y_pred)plt.show()","categories":[],"tags":[]},{"title":"2.1 线性回归","slug":"2-1-线性回归","date":"2019-05-23T07:49:41.000Z","updated":"2019-05-23T08:20:50.951Z","comments":true,"path":"2019/05/23/2-1-线性回归/","link":"","permalink":"http://yoursite.com/2019/05/23/2-1-线性回归/","excerpt":"","text":"一元线性回归可视化1234import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport seaborn as sns 导入数据集 12student_mom_revised = pd.read_csv('student_mom_revised.csv', index_col=0)student_mom_revised.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201409WhiteMALE197946989.06WhiteEmployedNORTHEASTDivorced4556743Unemployed41220.0NORTHEASTSeparated17043BlackMALE198147475.013WhiteUnemployedNORTH CENTRALNever Married2095978Unemployed40202.0NORTH CENTRALNever Married28797HISPANICFEMALE199025328.014BlackUnemployedWESTNever Married509829Unemployed21774.0WESTWidowed33040BlackMALE19822813113.07WhiteEmployedNORTHEASTMarried5781214Out of Labor60610.0NORTHEASTMarried41137WhiteMALE2001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarried 拟合母亲的智商(TOTAL IQ SCORE)和学生学业成绩(Score) 123456sns.set(style=\"darkgrid\")g = sns.regplot('TOTAL IQ SCORE', \"Score\", data=student_mom_revised, scatter_kws=&#123;'s': 10, 'color':'skyblue','alpha': 0.5&#125;, line_kws=&#123;\"color\":\"g\",\"alpha\":0.7,\"lw\":2&#125;)plt.show() /root/anaconda3/lib/python3.6/site-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval 如何获得拟合后曲线的斜率与截距？1.提取拟合后的数据点 12345x = g.get_lines()[0].get_xdata()y = g.get_lines()[0].get_ydata()plt.plot(x, y)plt.show() 拟合曲线参数 1234from scipy import statsslope, intercept, r_value, p_value, std_err = stats.linregress(x=g.get_lines()[0].get_xdata(), y=g.get_lines()[0].get_ydata()) 12print(slope)print(intercept) 0.4261880887166798 16.913131648115936 提取2000年后出生的学生 1children_after_00 = student_mom_revised[student_mom_revised['birthyear']&gt;2000] 通过jointplot()制作回归图，并显示X和Y的分布 1234sns.set(style=\"darkgrid\")g = sns.jointplot('TOTAL NET FAMILY INCOME 2014', \"Score\", data=children_after_00,kind='reg')plt.show() /root/anaconda3/lib/python3.6/site-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval 将jointplot()中参数kind的值变为hex,我们可以通过一个一个六边形(Hexagon)来展示两个变量的相互关系。 1234sns.set(style=\"darkgrid\")g = sns.jointplot('TOTAL NET FAMILY INCOME 2014', \"Score\", data=children_after_00,kind='hex')plt.show() /root/anaconda3/lib/python3.6/site-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval 针对children_after_00，分析不同2014年不同婚姻状况(MARITAL STATUS 2014),家庭年收入与学业成绩的关系 12345sns.lmplot(y=\"Score\", x=\"TOTAL NET FAMILY INCOME 2014\", col=\"MARITAL STATUS 2014\", hue=\"MARITAL STATUS 2014\", data=children_after_00, col_wrap=5, size=4)plt.show() /root/anaconda3/lib/python3.6/site-packages/seaborn/regression.py:546: UserWarning: The `size` paramter has been renamed to `height`; please update your code. warnings.warn(msg, UserWarning) /root/anaconda3/lib/python3.6/site-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval 随堂练习 1针对children_after_00,通过一元线性回归拟合AFQT和Score的关系 123456# grader format### BEGIN SOLUTIONg = sns.regplot('AFQT', \"Score\", data=children_after_00)### END SOLUTIONplt.show() /root/anaconda3/lib/python3.6/site-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval 随堂练习 2通过六边形图(Hexagon)展示AFQT和Score的关系。 1234567# grader format### BEGIN SOLUTIONg = sns.jointplot('AFQT', \"Score\", data=children_after_00,kind='hex')### END SOLUTIONplt.show() /root/anaconda3/lib/python3.6/site-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval 随堂练习 3针对children_after_00，分析不同母亲不同的种族(RACIAL),母亲智商(TOTAL IQ SCORE)与家庭收入(TOTAL NET FAMILY INCOME 2014)的关系。 12345678# grader format### BEGIN SOLUTIONsns.lmplot(x=\"TOTAL IQ SCORE\", y=\"TOTAL NET FAMILY INCOME 2014\", col=\"RACIAL\", hue=\"RACIAL\", data=children_after_00, col_wrap=5, size=4)### END SOLUTIONplt.show() /root/anaconda3/lib/python3.6/site-packages/seaborn/regression.py:546: UserWarning: The `size` paramter has been renamed to `height`; please update your code. warnings.warn(msg, UserWarning) /root/anaconda3/lib/python3.6/site-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval 字符串编码数据集中部分数据集不是数字而是字符串，比如婚姻状况，种族，这些变量对于学业成绩同样有很大的影响，我们需要把这些字符串变成数字。我们首先复制数据集 1children_00_revised = children_after_00.copy() 将children_00_revised中childsex的MALE改为1以及FEMALE改为2 12children_00_revised['childsex']=children_00_revised['childsex'].map(&#123;'MALE':1, 'FEMALE':2&#125;)children_00_revised.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201441137White12001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarried793536White1200336682.05BlackOut of LaborNORTH CENTRALNever Married3667954Out of Labor24751.0NORTH CENTRALSeparated898854Black1200439227.013BlackOut of LaborNORTH CENTRALSeparated2041138Out of Labor4652.0NORTH CENTRALSeparated1516409Black220044318115.013HISPANICIn Active ForcesNORTH CENTRALDivorced6133234Employed51250.0NORTH CENTRALSeparated2377000HISPANIC22001791683.014HISPANICEmployedNORTH CENTRALMarried4402130Unemployed60945.0SOUTHMarried 将children_00_revised中childrace的HISPANIC改为1，Black改为2，White改为3 12children_00_revised['childrace']=children_00_revised['childrace'].map(&#123;'HISPANIC':1, 'Black':2, 'White':3&#125;)children_00_revised.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201441137312001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarried79353631200336682.05BlackOut of LaborNORTH CENTRALNever Married3667954Out of Labor24751.0NORTH CENTRALSeparated89885421200439227.013BlackOut of LaborNORTH CENTRALSeparated2041138Out of Labor4652.0NORTH CENTRALSeparated15164092220044318115.013HISPANICIn Active ForcesNORTH CENTRALDivorced6133234Employed51250.0NORTH CENTRALSeparated2377000122001791683.014HISPANICEmployedNORTH CENTRALMarried4402130Unemployed60945.0SOUTHMarried 随堂练习 4将children_00_revised中RACIAL的HISPANIC改为1，Black改为2，White改为3。 123456# grader format### BEGIN SOLUTIONchildren_00_revised['RACIAL']=children_00_revised['RACIAL'].map(&#123;'HISPANIC':1, 'Black':2, 'White':3&#125;)children_00_revised.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201441137312001781580.053EmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarried79353631200336682.052Out of LaborNORTH CENTRALNever Married3667954Out of Labor24751.0NORTH CENTRALSeparated89885421200439227.0132Out of LaborNORTH CENTRALSeparated2041138Out of Labor4652.0NORTH CENTRALSeparated15164092220044318115.0131In Active ForcesNORTH CENTRALDivorced6133234Employed51250.0NORTH CENTRALSeparated2377000122001791683.0141EmployedNORTH CENTRALMarried4402130Unemployed60945.0SOUTHMarried 随堂练习 5将children_00_revised复制为children_revised_v2将children_revised_v2中MARITAL STATUS 2014的Never Married改为0，Married改为1，Separated改为2, Divorced改为3，REMARRIED改为5，Widowed改为6 123456789101112# grader format### BEGIN SOLUTIONchildren_revised_v2 = children_00_revised.copy()children_revised_v2['MARITAL STATUS 2014']=children_revised_v2['MARITAL STATUS 2014'].map(&#123;'Never Married':0, 'Married':1, 'Separated':2, 'Divorced':3, 'REMARRIED':5, 'Widowed':5&#125;)children_revised_v2.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201441137312001781580.053EmployedSOUTHSeparated6408227In Active Forces47115.0SOUTH179353631200336682.052Out of LaborNORTH CENTRALNever Married3667954Out of Labor24751.0NORTH CENTRAL289885421200439227.0132Out of LaborNORTH CENTRALSeparated2041138Out of Labor4652.0NORTH CENTRAL215164092220044318115.0131In Active ForcesNORTH CENTRALDivorced6133234Employed51250.0NORTH CENTRAL22377000122001791683.0141EmployedNORTH CENTRALMarried4402130Unemployed60945.0SOUTH1 多元线性回归1from sklearn import linear_model 从零开始构建一元线性回归拟合children_revised_v2中白人母亲(‘RACIAL’==2)的TOTAL IQ SCORE和Score的关系 12X=children_revised_v2[children_revised_v2['RACIAL']==2]['TOTAL IQ SCORE']y=children_revised_v2[children_revised_v2['RACIAL']==2]['Score'] 构建回归模型并展示预测结果 1234regr = linear_model.LinearRegression()regr.fit(np.array(X).reshape(-1,1), y)print('Coefficients:%s, intercept %.2f'%(regr.coef_, regr.intercept_))print('Score %.3f' % regr.score(np.array(X).reshape(-1,1),y)) Coefficients:[0.38378059], intercept 14.68 Score 0.476 模型结果可视化 1234567X_pred = np.arange(0, np.max(X), 10)y_pred = regr.predict(X_pred.reshape(-1,1))plt.plot(X_pred, y_pred, c='g')plt.scatter(X, y)plt.legend(['$y=0.38x+14.68$'])plt.show() 从零构建多元线性回归拟合children_revised_v2中白人母亲(‘RACIAL’==2)的TOTAL IQ SCORE，TOTAL NET FAMILY INCOME 2014，MARITAL STATUS 2014和Score的关系 1234X=children_revised_v2[children_revised_v2['RACIAL']==2][['TOTAL IQ SCORE', 'TOTAL NET FAMILY INCOME 2014', 'MARITAL STATUS 2014']]y=children_revised_v2[children_revised_v2['RACIAL']==2]['Score'] 12345from sklearn import datasets, linear_modelregr = linear_model.LinearRegression()regr.fit(X, y)print('Coefficients:%s, intercept %.2f'%(regr.coef_, regr.intercept_))print('Score %.3f' % regr.score(X,y)) Coefficients:[3.43557255e-01 1.30563685e-04 1.99288314e+00], intercept 9.36 Score 0.506 随堂练习 6在children_revised_v2中提取白人母亲的TOTAL IQ SCORE作为X，白人母亲的TOTAL NET FAMILY INCOME 2014作为y 123456# grader format### BEGIN SOLUTIONX=children_revised_v2[children_revised_v2['RACIAL']==2]['TOTAL IQ SCORE']y=children_revised_v2[children_revised_v2['RACIAL']==2]['TOTAL NET FAMILY INCOME 2014']### END SOLUTION 随堂练习 7以上题中的X和y构建一元线性回归模型，打印出模型的Score。 1234567# grader format### BEGIN SOLUTIONregr = linear_model.LinearRegression()regr.fit(np.array(X).reshape(-1,1), y)print('Score %.3f' % regr.score(np.array(X).reshape(-1,1),y))### END SOLUTION Score 0.575 课后练习 1针对children_revised_v2,使用regplot展示TOTAL NET FAMILY INCOME 2014和Score的线性关系 123456# grader format### BEGIN SOLUTIONg = sns.regplot('TOTAL NET FAMILY INCOME 2014', 'Score', data=children_revised_v2)### END SOLUTIONplt.show() /root/anaconda3/lib/python3.6/site-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval 课后练习 2将children_revised_v2中REGION 2014的NORTHEAST改为1，NORTH CENTRAL改为2，SOUTH改为3, WEST改为4。并显示前5行。 123456789# grader format### BEGIN SOLUTIONchildren_revised_v2['REGION 2014']=children_revised_v2['REGION 2014'].map(&#123;'NORTHEAST':1, 'NORTH CENTRAL':2, 'SOUTH':3, 'WEST':4&#125;)children_revised_v2.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201441137312001781580.053EmployedSOUTHSeparated6408227In Active Forces47115.03179353631200336682.052Out of LaborNORTH CENTRALNever Married3667954Out of Labor24751.02289885421200439227.0132Out of LaborNORTH CENTRALSeparated2041138Out of Labor4652.02215164092220044318115.0131In Active ForcesNORTH CENTRALDivorced6133234Employed51250.0222377000122001791683.0141EmployedNORTH CENTRALMarried4402130Unemployed60945.031 课后练习 3提取children_revised_v2中白人母亲(‘RACIAL’==2)的TOTAL IQ SCORE，TOTAL NET FAMILY INCOME 2014，REGION 2014和Score的关系。 12345678# grader format### BEGIN SOLUTIONX=children_revised_v2[children_revised_v2['RACIAL']==2][['TOTAL IQ SCORE', 'TOTAL NET FAMILY INCOME 2014', 'REGION 2014']]y=children_revised_v2[children_revised_v2['RACIAL']==2]['Score']### END SOLUTION 课后练习 4拟合上题中X和y的线性关系，打印出模型中各变量的系数以及模型的score值。 12345678# grader format### BEGIN SOLUTIONregr = linear_model.LinearRegression()regr.fit(X, y)print('Coefficients:%s, intercept %.2f'%(regr.coef_, regr.intercept_))print('Score %.3f' % regr.score(X,y))### END SOLUTION Coefficients:[ 3.06128361e-01 1.90233958e-04 -2.57011642e+00], intercept 20.18 Score 0.499 12","categories":[],"tags":[]},{"title":"1.4 母亲对孩子的影响","slug":"1-4-母亲对孩子的影响","date":"2019-05-23T07:48:59.000Z","updated":"2019-05-23T08:19:36.601Z","comments":true,"path":"2019/05/23/1-4-母亲对孩子的影响/","link":"","permalink":"http://yoursite.com/2019/05/23/1-4-母亲对孩子的影响/","excerpt":"","text":"123456import pandas as pdimport numpy as npimport seaborn as snsimport matplotlib.pyplot as pltimport warningswarnings.simplefilter(action='ignore', category=FutureWarning) 导入数据并显示前5行 12student_mom_revised = pd.read_csv('student_mom_revised.csv', index_col=0)student_mom_revised.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201409WhiteMALE197946989.06WhiteEmployedNORTHEASTDivorced4556743Unemployed41220.0NORTHEASTSeparated17043BlackMALE198147475.013WhiteUnemployedNORTH CENTRALNever Married2095978Unemployed40202.0NORTH CENTRALNever Married28797HISPANICFEMALE199025328.014BlackUnemployedWESTNever Married509829Unemployed21774.0WESTWidowed33040BlackMALE19822813113.07WhiteEmployedNORTHEASTMarried5781214Out of Labor60610.0NORTHEASTMarried41137WhiteMALE2001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarried 通过stripplot展示母亲获得不同学历对于孩子教育的影响 123g1 = sns.stripplot(x=\"HIGHEST GRADE COMPLETED\", y=\"Score\", s=7,data=student_mom_revised, jitter=True)#plt.xticks(rotation=60)plt.show() 随堂练习 1通过stripplot展示不同学历的母亲的TOTAL IQ SCORE的分布情况 12345678# grader format### BEGIN SOLUTIONg1 = sns.stripplot(x=\"HIGHEST GRADE COMPLETED\", y=\"TOTAL IQ SCORE\", s=7, data=student_mom_revised, jitter=True)### END SOLUTIONplt.show() 条形图程序实现通过条形图分析获得不同学位的母亲培养出来的学生的平均学业成绩 1234567y = student_mom_revised['Score']x = student_mom_revised['HIGHEST GRADE COMPLETED']f,ax = plt.subplots(figsize = (9,5))sns.barplot(x,y,errwidth=0)ax.set(xlabel='HIGHEST GRADE COMPLETED', ylabel='Score')plt.show() 由此可知母亲的学历越高导致孩子的成绩越好。不同种族的母亲所获得的平均学历是怎么样的？ 12345f,ax = plt.subplots(figsize = (9,5))sns.set_color_codes(\"pastel\")sns.barplot(x=student_mom_revised['HIGHEST GRADE COMPLETED'],y=student_mom_revised['RACIAL'], color='purple',label=\"Grade\",errwidth=0)plt.show() 重点分析白人母亲和黑人母亲 12white_mom = student_mom_revised[student_mom_revised['RACIAL'] == 'White']black_mom = student_mom_revised[student_mom_revised['RACIAL'] == 'Black'] 提取白人母亲和黑人母亲数据集中提取HIGHEST GRADE COMPLETED和AFQT 1234white_grade = np.mean(white_mom['HIGHEST GRADE COMPLETED'])white_afqt = np.mean(white_mom['AFQT'])black_grade = np.mean(black_mom['HIGHEST GRADE COMPLETED'])black_afqt = np.mean(black_mom['AFQT']) 条形图参数 12345x1 = 0x2 = 1.5total_width, n = 1.2, 2width = total_width / n 制作并列条形图 123456789plt.bar(x1,white_grade, width=width, label='Grade',color='b')plt.bar(x1 + width, white_afqt, width=width, label='AFQT',color='r')plt.bar(x2, black_grade, width=width, color='b')plt.bar(x2 + width, black_afqt, width=width,color='r')plt.title('White Mom vs Black Mom in Grade and AFQT')plt.xticks([0.3, 1.8], ('White Mom', 'Black Mom'))plt.legend()plt.show() 随堂练习 2通过条形图展示不同种族的母亲平均智商的区别(TOTAL IQ SCORE) 12345678910# grader formatf,ax = plt.subplots(figsize = (9,5))sns.set_color_codes(\"pastel\")### BEGIN SOLUTIONsns.barplot(x=student_mom_revised['TOTAL IQ SCORE'],y=student_mom_revised['RACIAL'], color='blue',alpha=0.5,errwidth=0)plt.show()### END SOLUTION 随堂练习 3我们已经提取了白人母亲和黑人母亲的相关数据：IQ值，AFQT成绩以及孩子Score值，请用并列条形图来进行比较 1234567891011121314151617181920212223242526# grader formatwhite_iq = np.mean(white_mom['TOTAL IQ SCORE'])white_afqt = np.mean(white_mom['AFQT'])white_score = np.mean(white_mom['Score'])black_iq = np.mean(black_mom['TOTAL IQ SCORE'])black_afqt = np.mean(black_mom['AFQT'])black_score = np.mean(black_mom['Score'])x1 = 0x2 = 2.0total_width, n = 1.2, 3width = total_width / n ### BEGIN SOLUTIONplt.bar(x1,white_iq, width=width, label='IQ',color='b')plt.bar(x1 + width, white_score, width=width, label='Score',color='r')plt.bar(x1 + 2*width, white_afqt, width=width, label='AFQT',color='g')plt.bar(x2, black_iq, width=width, color='b')plt.bar(x2 + width, black_score, width=width,color='r')plt.bar(x2 + 2*width, white_afqt, width=width,color='g')### END SOLUTIONplt.title('White Mom and Black Mom ')plt.xticks([0.4, 2.4], ('White Mom', 'Black Mom'))plt.legend()plt.show() 箱形图分析用箱形图来展示Score的分布 1234import seaborn as snssns.set(style=\"whitegrid\")ax = sns.boxplot(x=student_mom_revised[\"Score\"])plt.show() 比较1979年母亲不同就业状况对于学生成绩的影响 12ax = sns.boxplot(x=\"EMPLOYMENT STATUS 1979\", y=\"Score\", data=student_mom_revised)plt.show() 提取白人母亲和黑人母亲的数据集 12white_black_data = student_mom_revised[(student_mom_revised['RACIAL'] == 'White') | (student_mom_revised['RACIAL'] == 'Black')] 通过箱形图来比较白人母亲和黑人母亲在不同就业状况对于学生成绩的影响 1234f,ax = plt.subplots(figsize = (9,6))ax = sns.boxplot(x=\"EMPLOYMENT STATUS 1979\", y=\"Score\", hue=\"RACIAL\",data=white_black_data, palette=\"Set3\")plt.legend(loc='lower left')plt.show() 在white_black_data数据集上增加一列，如果’HIGHEST GRADE COMPLETED’大于等于12则为True，小于12为False 12white_black_data['12 grade or more'] = white_black_data['HIGHEST GRADE COMPLETED'] &gt;= 12white_black_data.head(5) /root/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy &quot;&quot;&quot;Entry point for launching an IPython kernel. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201412 grade or more09WhiteMALE197946989.06WhiteEmployedNORTHEASTDivorced4556743Unemployed41220.0NORTHEASTSeparatedFalse17043BlackMALE198147475.013WhiteUnemployedNORTH CENTRALNever Married2095978Unemployed40202.0NORTH CENTRALNever MarriedFalse28797HISPANICFEMALE199025328.014BlackUnemployedWESTNever Married509829Unemployed21774.0WESTWidowedFalse33040BlackMALE19822813113.07WhiteEmployedNORTHEASTMarried5781214Out of Labor60610.0NORTHEASTMarriedTrue41137WhiteMALE2001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarriedTrue 通过比较母亲学历水平(是否在12年级以上)，来分析不同种族的母亲在不同工作状态下教育孩子的成果 12345#f,ax = plt.subplots(figsize = (12,8))ax = sns.catplot(x=\"EMPLOYMENT STATUS 1979\", y=\"Score\", hue=\"RACIAL\", col=\"12 grade or more\",data=white_black_data, kind=\"box\")plt.show() 随堂练习 4通过箱形图，展示student_mom_revised数据集中”TOTAL NET FAMILY INCOME 1979”的分布情况 1234567# grader formatsns.set(style=\"whitegrid\")### BEGIN SOLUTIONax = sns.boxplot(x=student_mom_revised[\"TOTAL NET FAMILY INCOME 1979\"])### END SOLUTIONplt.show() 随堂练习 5针对white_black_data数据集，通过箱形图分析，1979年不同工作状态下(EMPLOYMENT STATUS 1979)，不同肤色（RACIAL）的母亲的家庭收入(TOTAL NET FAMILY INCOME 1979)的区别。 12345678910# grader formatf,ax = plt.subplots(figsize = (9,6))### BEGIN SOLUTIONax = sns.boxplot(x=\"EMPLOYMENT STATUS 1979\", y=\"TOTAL NET FAMILY INCOME 1979\", hue=\"RACIAL\",data=white_black_data, palette=\"Set3\")### END SOLUTIONplt.legend(loc='lower left')plt.show() 课后练习 1通过stripplot图来分析student_mom_revised中母亲在2014年的婚姻情况(MARITAL STATUS 2014)与孩子学业成绩的关系Score。 1234567# grader format### BEGIN SOLUTIONg1 = sns.stripplot(x='MARITAL STATUS 2014', y=\"Score\", s=7,data=student_mom_revised, jitter=True)### END SOLUTIONplt.xticks(rotation=60)plt.show() 课后练习 2通过条形图展示母亲2014年不同的婚姻状况下，孩子的学业成绩平均分。 123456789# grader formatf,ax = plt.subplots(figsize = (9,5))sns.set_color_codes(\"pastel\")### BEGIN SOLUTIONsns.barplot(x=student_mom_revised['Score'],y=student_mom_revised['MARITAL STATUS 2014'], color='skyblue',label=\"Grade\",errwidth=0)plt.show()### END SOLUTION 课后练习 3通过箱形图展示母亲2014年不同的婚姻状况下，孩子的学业成绩的分布。 1234567# grader format### BEGIN SOLUTIONax = sns.boxplot(x=\"MARITAL STATUS 2014\", y=\"Score\", data=student_mom_revised)### END SOLUTIONplt.xticks(rotation=60)plt.show() 课后练习 4运用箱形图，通过white_black_data来区分白人母亲和黑人母亲在2014年不同工作状态下，孩子的成绩分布。 12345678910# grader formatf,ax = plt.subplots(figsize = (9,6))### BEGIN SOLUTIONax = sns.boxplot(x=\"MARITAL STATUS 2014\", y=\"Score\", hue=\"RACIAL\", data=white_black_data, palette=\"Set3\")### END SOLUTIONplt.legend(loc='upper right')plt.show() 12 12","categories":[],"tags":[]},{"title":"1.3 家庭对孩子的影响","slug":"1-3-家庭对孩子的影响","date":"2019-05-23T07:48:29.000Z","updated":"2019-05-23T08:17:46.661Z","comments":true,"path":"2019/05/23/1-3-家庭对孩子的影响/","link":"","permalink":"http://yoursite.com/2019/05/23/1-3-家庭对孩子的影响/","excerpt":"","text":"直方图程序实现12import pandas as pdimport matplotlib.pyplot as plt 导入数据集(student_mom_revised.csv)并显示前5行 12student_mom_revised = pd.read_csv('student_mom_revised.csv', index_col=0)student_mom_revised.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201409WhiteMALE197946989.06WhiteEmployedNORTHEASTDivorced4556743Unemployed41220.0NORTHEASTSeparated17043BlackMALE198147475.013WhiteUnemployedNORTH CENTRALNever Married2095978Unemployed40202.0NORTH CENTRALNever Married28797HISPANICFEMALE199025328.014BlackUnemployedWESTNever Married509829Unemployed21774.0WESTWidowed33040BlackMALE19822813113.07WhiteEmployedNORTHEASTMarried5781214Out of Labor60610.0NORTHEASTMarried41137WhiteMALE2001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarried 提取母子都是白人以及母子都是黑人的数据集 1234white_family = student_mom_revised[(student_mom_revised['childrace'] == 'White') &amp; (student_mom_revised['RACIAL'] == 'White')]black_family = student_mom_revised[(student_mom_revised['childrace'] == 'Black') &amp; (student_mom_revised['RACIAL'] == 'Black')] 分别制作两组数据学生学业成绩的直方图 12345678910white_family['Score'].hist(bins=20)plt.title('White Family')plt.xlabel('Score')plt.ylabel('Number')plt.show()black_family['Score'].hist(bins=20)plt.title('Black Family')plt.xlabel('Score')plt.ylabel('Number')plt.show() 白人家庭相比于黑人家庭，更注重教育，孩子的成绩普遍更优秀。 查看家庭所在的不同区域 1student_mom_revised['REGION 1979'].unique() array([&apos;NORTHEAST&apos;, &apos;NORTH CENTRAL&apos;, &apos;WEST&apos;, &apos;SOUTH&apos;], dtype=object) 根据’REGION 1979’的不同区域提取数据集 1234NE_data = student_mom_revised[student_mom_revised['REGION 1979'] == 'NORTHEAST']NC_data = student_mom_revised[student_mom_revised['REGION 1979'] == 'NORTH CENTRAL']W_data = student_mom_revised[student_mom_revised['REGION 1979'] == 'WEST']S_data = student_mom_revised[student_mom_revised['REGION 1979'] == 'SOUTH'] 制作四个不同区域，学生学业成绩的直方图 123456789101112fig, axes=plt.subplots(nrows=2, ncols=2, sharex=True, sharey=True, figsize=(8,5))NE_data['Score'].hist(ax=axes[0,0])NC_data['Score'].hist(ax=axes[0,1])W_data['Score'].hist(ax=axes[1,0])S_data['Score'].hist(ax=axes[1,1])axes[0,0].set_title('NORTHEAST')axes[0,1].set_title('NORTH CENTRAL')axes[1,0].set_title('WEST')axes[1,1].set_title('SOUTH')plt.show() 从直方图中，可以看出南部地区的人数最多，而且相对地学生学业成绩集中在40-50分左右，这也符合美国国情，南部教育资源没有那么丰富，尤其相比于名校云集，著名的常青藤盟校聚集的东北地区。接下来，我们对比下四个地区的人口迁移情况 1student_mom_revised.groupby(['REGION 1979']).size() REGION 1979 NORTH CENTRAL 2685 NORTHEAST 1998 SOUTH 4048 WEST 2144 dtype: int64 1student_mom_revised.groupby(['REGION 2014']).size() REGION 2014 NORTH CENTRAL 2491 NORTHEAST 1755 SOUTH 4503 WEST 2126 dtype: int64 仅从我们的数据集看，美国似乎没有孟母三迁的文化，南部虽然教育水平不高，但是由于地理优势，宜居等特点，使比较多的家庭迁徙至南部地区。 随堂练习 1计算1979年以及2014年，SOUTH地区的学生学业成绩(Score)的平均分。 12345678910# grader formatimport numpy as np### BEGIN SOLUTIONSOUTH_1979 = student_mom_revised[student_mom_revised['REGION 1979'] == 'SOUTH']SOUTH_2014 = student_mom_revised[student_mom_revised['REGION 2014'] == 'SOUTH']print(np.mean(SOUTH_1979['Score']))print(np.mean(SOUTH_2014['Score']))### END SOLUTION 50.21837944664031 50.98689762380635 随堂练习 2制作2014年SOUTH地区，学生学业成绩的直方图。 1234567# grader format### BEGIN SOLUTIONSOUTH_2014 = student_mom_revised[student_mom_revised['REGION 2014'] == 'SOUTH']plt.hist(SOUTH_2014['Score'], alpha=0.4, bins=20)### END SOLUTIONplt.show() 数据分布拟合根据2014年以及1979年家庭收入变化来提取数据 1234increase = student_mom_revised[student_mom_revised['TOTAL NET FAMILY INCOME 1979'] &lt; student_mom_revised['TOTAL NET FAMILY INCOME 2014']]decrease = student_mom_revised[student_mom_revised['TOTAL NET FAMILY INCOME 1979'] &gt; student_mom_revised['TOTAL NET FAMILY INCOME 2014']] 制作直方图 1234plt.hist(increase['Score'], alpha=0.4, bins=20)plt.hist(decrease['Score'], alpha=0.4, bins=20)plt.legend(['Increase', 'Decrease'])plt.show() 家庭收入增加比减少的人数多很多，通过直方图无法直观地展示两者的区别，我们可以通过分布来解决这个问题 123456import seaborn as snssns.kdeplot(increase['Score'])sns.kdeplot(decrease['Score'])plt.show() /root/anaconda3/lib/python3.7/site-packages/scipy/stats/stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval 通过分布我们可以发现家庭收入变化并不会明显改变学生学业成绩，家庭收入的提高不会改善学生的学业情况，反而家庭收入降低可能会激发学生学习愿望迫使学生获得更好的分数。 分析婚姻状况含有哪些状态 1student_mom_revised['MARITAL STATUS 1979'].unique() array([&apos;Divorced&apos;, &apos;Never Married&apos;, &apos;Married&apos;, &apos;Separated&apos;, &apos;Widowed&apos;], dtype=object) 提取1979年以及2014年，家庭婚姻状况均为Married，我们假设这部分孩子长期在完整家庭中长大。提取1979年以及2014年，家庭婚姻状况均不为Married，我们假设这部分孩子长期在不完整家庭中长大。 1234married = student_mom_revised[(student_mom_revised['MARITAL STATUS 1979'] == 'Married') &amp; (student_mom_revised['MARITAL STATUS 2014'] == 'Married')]unmarried = student_mom_revised[(student_mom_revised['MARITAL STATUS 1979'] != 'Married') &amp; (student_mom_revised['MARITAL STATUS 2014']!= 'Married')] 制作分布图对比这两类学生的学业成绩 1234sns.kdeplot(married['Score'])sns.kdeplot(unmarried['Score'])plt.legend(['Married', 'Unmarried'], loc='upper left')plt.show() 家庭是否完整以及是否和睦对于孩子的长期发展以及学业成绩有极大的影响，通过分布我们可以看出在完整家庭中长大的孩子平均分高而且方差小。这验证了父母是孩子最重要的老师。我们在数据集中新增一列’Martial Status’,如果1979年和2014年婚姻状况均为Married，则显示为True，否则显示为False 12student_mom_revised['Marital Status'] = (student_mom_revised['MARITAL STATUS 1979'] == 'Married') &amp; \\(student_mom_revised['MARITAL STATUS 2014'] == 'Married') 1student_mom_revised.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 2014Marital Status09WhiteMALE197946989.06WhiteEmployedNORTHEASTDivorced4556743Unemployed41220.0NORTHEASTSeparatedFalse17043BlackMALE198147475.013WhiteUnemployedNORTH CENTRALNever Married2095978Unemployed40202.0NORTH CENTRALNever MarriedFalse28797HISPANICFEMALE199025328.014BlackUnemployedWESTNever Married509829Unemployed21774.0WESTWidowedFalse33040BlackMALE19822813113.07WhiteEmployedNORTHEASTMarried5781214Out of Labor60610.0NORTHEASTMarriedTrue41137WhiteMALE2001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarriedFalse 根据’Marital Status’分类并且计算每类的人数 1student_mom_revised.groupby(['Marital Status']).size() Marital Status False 9596 True 1279 dtype: int64 根据’Marital Status’分类并且计算每类的平均数 1student_mom_revised['Score'].groupby(student_mom_revised['Marital Status']).mean() Marital Status False 50.803981 True 71.754496 Name: Score, dtype: float64 随堂练习 3在课程中我们通过plt.hist()函数分析了家庭收入增加与减少对于学生学业成绩的影响，由于两类的人数不同，直接比较直方图没有什么以及，我们借助了分布，其实我们借助plt.hist()中的density=True，来计算概率密度，来比较两者的区别。 1234567# grader format### BEGIN SOLUTIONplt.hist(increase['Score'], alpha=0.4, bins=20, density=True)plt.hist(decrease['Score'], alpha=0.4, bins=20,density=True)plt.show()### END SOLUTION 随堂练习 4将数据集student_mom_revised根据2014年的家庭总收入是否大于50000进行分组，并作出这两类学生学业成绩的分布图 1234567891011# grader format### BEGIN SOLUTIONover_5 = student_mom_revised[student_mom_revised['TOTAL NET FAMILY INCOME 2014'] &gt; 50000]below_5 = student_mom_revised[student_mom_revised['TOTAL NET FAMILY INCOME 2014'] &lt; 50000]sns.kdeplot(over_5['Score'])sns.kdeplot(below_5['Score'])### END SOLUTIONplt.legend(['Over 50 grand', 'Below 50 grand'])plt.show() 课后练习 1在student_mom_revised数据集中新增一列’income over 50 grand’，如果2014家庭总收入在50000以上，则该列的值为True，如果少于50000则该值为False 123456# grader format### BEGIN SOLUTIONstudent_mom_revised['income over 50 grand'] = student_mom_revised['TOTAL NET FAMILY INCOME 2014'] &gt; 50000student_mom_revised.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 2014Marital Statusincome over 50 grand09WhiteMALE197946989.06WhiteEmployedNORTHEASTDivorced4556743Unemployed41220.0NORTHEASTSeparatedFalseFalse17043BlackMALE198147475.013WhiteUnemployedNORTH CENTRALNever Married2095978Unemployed40202.0NORTH CENTRALNever MarriedFalseFalse28797HISPANICFEMALE199025328.014BlackUnemployedWESTNever Married509829Unemployed21774.0WESTWidowedFalseFalse33040BlackMALE19822813113.07WhiteEmployedNORTHEASTMarried5781214Out of Labor60610.0NORTHEASTMarriedTrueTrue41137WhiteMALE2001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarriedFalseFalse 课后练习 2根据groupby的参考材料http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html先对Marital进行分组，然后再对income over 50 grand分组，并统计每组的个数 12345# grader format### BEGIN SOLUTIONstudent_mom_revised.groupby(['Marital Status','income over 50 grand']).size()### END SOLUTION Marital Status income over 50 grand False False 5754 True 3842 True False 197 True 1082 dtype: int64 课后练习 3根据groupby的参考材料http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html先对Marital进行分组，然后再对income over 50 grand分组，并计算每组学生学业成绩的平均数。 123456# grader format### BEGIN SOLUTIONstudent_mom_revised.groupby([student_mom_revised['Marital Status'], student_mom_revised['income over 50 grand']])['Score'].mean()### END SOLUTION Marital Status income over 50 grand False False 39.494439 True 67.741801 True False 62.918782 True 73.363216 Name: Score, dtype: float64 课后练习 4根据Marital Status以及income over 50 grand对数据集进行分组，我们可以分成四组，制作这四组学生学业成绩的分布图 12345678910111213141516171819# grader format### BEGIN SOLUTIONdf_1 = student_mom_revised[(student_mom_revised['Marital Status'] == True) &amp; (student_mom_revised['income over 50 grand'] == True)]df_2 = student_mom_revised[(student_mom_revised['Marital Status'] == False) &amp; (student_mom_revised['income over 50 grand'] == True)]df_3 = student_mom_revised[(student_mom_revised['Marital Status'] == True) &amp; (student_mom_revised['income over 50 grand'] == False)]df_4 = student_mom_revised[(student_mom_revised['Marital Status'] == False) &amp; (student_mom_revised['income over 50 grand'] == False)]sns.kdeplot(df_1['Score'])sns.kdeplot(df_2['Score'])sns.kdeplot(df_3['Score'])sns.kdeplot(df_4['Score'])### END SOLUTIONplt.legend(['Group 1', 'Group 2', 'Group 3', 'Group 4'])plt.show() 12","categories":[],"tags":[]},{"title":"1.2 影响学业的变量分析","slug":"1-2-影响学业的变量分析","date":"2019-05-23T07:47:55.000Z","updated":"2019-05-23T08:15:38.537Z","comments":true,"path":"2019/05/23/1-2-影响学业的变量分析/","link":"","permalink":"http://yoursite.com/2019/05/23/1-2-影响学业的变量分析/","excerpt":"","text":"统计量计算程序实现123import pandas as pdstudent_mom_revised = pd.read_csv('student_mom_revised.csv', parse_dates=True, index_col=0)student_mom_revised.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201409WhiteMALE197946989.06WhiteEmployedNORTHEASTDivorced4556743Unemployed41220.0NORTHEASTSeparated17043BlackMALE198147475.013WhiteUnemployedNORTH CENTRALNever Married2095978Unemployed40202.0NORTH CENTRALNever Married28797HISPANICFEMALE199025328.014BlackUnemployedWESTNever Married509829Unemployed21774.0WESTWidowed33040BlackMALE19822813113.07WhiteEmployedNORTHEASTMarried5781214Out of Labor60610.0NORTHEASTMarried41137WhiteMALE2001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarried 计算1979年以及2014年家庭收入的最大值 12345max_income_1979 = max(student_mom_revised['TOTAL NET FAMILY INCOME 1979'])max_income_2014 = max(student_mom_revised['TOTAL NET FAMILY INCOME 2014'])print(max_income_1979)print(max_income_2014) 79243 94219.0 计算1979年以及2014年家庭收入的平均值 12345avg_income_1979 = student_mom_revised['TOTAL NET FAMILY INCOME 1979'].mean()avg_income_2014 = student_mom_revised['TOTAL NET FAMILY INCOME 2014'].mean()print(round(avg_income_1979,2))print(round(avg_income_2014,2)) 41042.76 45124.74 计算1979年以及2014年家庭收入的标准差 12345std_income_1979 = student_mom_revised['TOTAL NET FAMILY INCOME 1979'].std()std_income_2014 = student_mom_revised['TOTAL NET FAMILY INCOME 2014'].std()print(round(std_income_1979,2))print(round(std_income_2014,2)) 19796.09 18912.42 计算2014年家庭年收入在50000元以上与以下的孩子学业成绩区别 12345678data_over = student_mom_revised[student_mom_revised['TOTAL NET FAMILY INCOME 2014']&gt;50000]data_below = student_mom_revised[student_mom_revised['TOTAL NET FAMILY INCOME 2014']&lt;=50000]avg_score_over = data_over['Score'].mean()avg_score_before = data_below['Score'].mean()print(round(avg_score_over,2))print(round(avg_score_before,2)) 68.98 40.27 随堂练习 1计算学生成绩(Score)的方差并打印出来 123456# grader format### BEGIN SOLUTIONscore_std = student_mom_revised['Score'].std()### END SOLUTIONprint(score_std) 25.047743966970906 随堂练习 2计算智商值(TOTAL IQ SCORE)的最大值 123456# grader format### BEGIN SOLUTIONiq_max = max(student_mom_revised['TOTAL IQ SCORE'])### END SOLUTIONprint(iq_max) 196.0 随堂练习 3计算目前TOTAL IQ SCORE分数在100以上与以下，孩子学业成绩SCORE的区别 123456789101112# grader formatdata_over = student_mom_revised[student_mom_revised['TOTAL IQ SCORE']&gt;100]data_below = student_mom_revised[student_mom_revised['TOTAL IQ SCORE']&lt;=100]### BEGIN SOLUTIONavg_score_over = data_over['Score'].mean()avg_score_before = data_below['Score'].mean()### END SOLUTIONprint(round(avg_score_over,2))print(round(avg_score_before,2)) 68.01 43.31 散点图分析出生年分和学生成绩之间的关系 12345678910#Plotimport matplotlib.pyplot as plty1 = student_mom_revised['Score']x1 = student_mom_revised['birthyear']plt.scatter(x1,y1)plt.ylabel('Score')plt.xlabel('Birthyear')plt.show() &lt;Figure size 640x480 with 1 Axes&gt; 分析出生年分和学生成绩之间的关系 123456y = student_mom_revised['Score']x = student_mom_revised['TOTAL NET FAMILY INCOME 1979']plt.scatter(x, y)plt.xlabel('TOTAL NET FAMILY INCOME 1979')plt.ylabel('Score')plt.show() 提取白人，黑人，西班牙裔的数据 123white_data=student_mom_revised[student_mom_revised['childrace']=='White']black_data=student_mom_revised[student_mom_revised['childrace']=='Black']hispanic_data=student_mom_revised[student_mom_revised['childrace']=='HISPANIC'] 分别提取学业成绩和家庭1979年的年收入 123456y_w = white_data['Score']x_w = white_data['TOTAL NET FAMILY INCOME 1979']y_b = black_data['Score']x_b = black_data['TOTAL NET FAMILY INCOME 1979']y_h = hispanic_data['Score']x_h = hispanic_data['TOTAL NET FAMILY INCOME 1979'] 绘制散点图 1234567plt.scatter(x_w, y_w,c='r',alpha=0.5)plt.scatter(x_b, y_b,c='y',alpha=0.5)plt.scatter(x_h, y_h,c='g',alpha=0.5)plt.legend([ 'White', 'Black', 'Hispanic'])plt.xlabel('TOTAL NET FAMILY INCOME 1979')plt.ylabel('Score')plt.show() 提取1995后出生的白人与黑人的学生数据，x1轴为1979年的家庭收入，x2轴为2014年的家庭收入，散点大小表示学生成绩的高低 1234567891011121314151617white_after_1995 = student_mom_revised[(student_mom_revised['birthyear']&gt;1995) &amp; (student_mom_revised['childrace']=='White')]black_after_1995 = student_mom_revised[(student_mom_revised['birthyear']&gt;1995) &amp; (student_mom_revised['childrace']=='Black')]y_w = white_after_1995['Score']x_w1 = white_after_1995['TOTAL NET FAMILY INCOME 1979']x_w2 = white_after_1995['TOTAL NET FAMILY INCOME 2014']y_b = black_after_1995['Score']x_b1 = black_after_1995['TOTAL NET FAMILY INCOME 1979']x_b2 = black_after_1995['TOTAL NET FAMILY INCOME 2014']plt.scatter(x_w1, x_w2, s=y_w, c='r',alpha=0.5)plt.scatter(x_b1, x_b2, s=y_b, c='y',alpha=0.5)plt.xlabel('1979 Income')plt.ylabel('2014 Income')plt.show() 随堂练习 4计算智商值(TOTAL IQ SCORE)和学业成绩(Score)的关系 1234567891011# grader formatimport matplotlib.pyplot as plt### BEGIN SOLUTIONy1 = student_mom_revised['Score']x1 = student_mom_revised['TOTAL IQ SCORE']plt.scatter(x1,y1)### END SOLUTIONplt.ylabel('Score')plt.xlabel('IQ')plt.show() 随堂练习 5从white_data和black_data中分别提取’Score’和’TOTAL IQ SCORE’，通过散点图表示两者区别。 12345678910111213141516# grader format### BEGIN SOLUTIONy_w = white_data['Score']x_w = white_data['TOTAL IQ SCORE']y_b = black_data['Score']x_b = black_data['TOTAL IQ SCORE']plt.scatter(x_w, y_w,c='r',alpha=0.5)plt.scatter(x_b, y_b,c='y',alpha=0.5)### END SOLUTIONplt.legend([ 'White', 'Black'])plt.xlabel('TOTAL IQ SCORE')plt.ylabel('Score')plt.show() 相关性的程序实现计算1979年家庭年收入和2014年家庭年收入的相关系数 1234import numpy as npnp.corrcoef(student_mom_revised['TOTAL NET FAMILY INCOME 1979'], student_mom_revised['TOTAL NET FAMILY INCOME 2014'])[0][1] 0.8246637055432046 计算1979年家庭年收入和学生学业成绩的的相关系数 12np.corrcoef(student_mom_revised['TOTAL NET FAMILY INCOME 1979'], student_mom_revised['Score'])[0][1] 0.6854058087887732 12345678910import matplotlib.pyplot as pltimport seaborn as snssns.set(style=\"whitegrid\", palette=\"muted\")current_palette = sns.color_palette()%matplotlib inline# 15年的相关性图plt.figure(figsize=(16,16))corrmat = student_mom_revised.corr()sns.heatmap(corrmat, vmax=.8, square=True, annot=True) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7ff1b0e64fd0&gt; 随堂练习 6计算白人学生的家庭1979年收入与2014年收入的相关系数 12345678# grader format### BEGIN SOLUTIONwhite_data=student_mom_revised[student_mom_revised['childrace']=='White']np.corrcoef(white_data['TOTAL NET FAMILY INCOME 1979'], white_data['TOTAL NET FAMILY INCOME 2014'])[0][1]### END SOLUTION 0.8199882950498126 课后练习 1计算student_mom_revised数据集中Score的最大值和最小值 12345678# grader format### BEGIN SOLUTIONmax_score = max(student_mom_revised['Score'])min_score = min(student_mom_revised['Score'])### END SOLUTIONprint(max_score)print(min_score) 100 0 课后练习 2计算student_mom_revised数据集中提取孩子种族(childrace)为白人以及黑人的数据，计算白人以及黑人学生Score的标准差。 1234567891011# grader format### BEGIN SOLUTIONwhite_data=student_mom_revised[student_mom_revised['childrace']=='White']black_data=student_mom_revised[student_mom_revised['childrace']=='Black']std_white = white_data['Score'].std()std_black = black_data['Score'].std()### END SOLUTIONprint(std_white)print(std_black) 25.109949161698985 18.100973617713844 课后练习 3提取1995后出生的男生与女生的数据，x1轴为1979年的家庭收入，x2轴为2014年的家庭收入，散点大小表示学生成绩的高低 12345678910111213141516171819# grader format### BEGIN SOLUTIONmale_after_1995 = student_mom_revised[(student_mom_revised['birthyear']&gt;1995) &amp; (student_mom_revised['childsex']=='MALE')]female_after_1995 = student_mom_revised[(student_mom_revised['birthyear']&gt;1995) &amp; (student_mom_revised['childsex']=='FEMALE')]z_male = male_after_1995['Score']x_male = male_after_1995['TOTAL NET FAMILY INCOME 1979']y_male = male_after_1995['TOTAL NET FAMILY INCOME 2014']z_female = female_after_1995['Score']x_female = female_after_1995['TOTAL NET FAMILY INCOME 1979']y_female = female_after_1995['TOTAL NET FAMILY INCOME 2014']plt.scatter(x_male, y_male, s=z_male, c='r',alpha=0.5)plt.scatter(x_female, y_female, s=z_female, c='y',alpha=0.5)plt.show()### END SOLUTION 课后练习 4做出白人学生的相关性heatmap 12345678910111213# grader formatimport matplotlib.pyplot as pltimport seaborn as snssns.set(style=\"whitegrid\", palette=\"muted\")current_palette = sns.color_palette()%matplotlib inlinewhite_data=student_mom_revised[student_mom_revised['childrace']=='White']plt.figure(figsize=(16,16))### BEGIN SOLUTIONcorrmat = white_data.corr()sns.heatmap(corrmat, vmax=.8, square=True, annot=True)### END SOLUTION &lt;matplotlib.axes._subplots.AxesSubplot at 0x7ff1b0786908&gt; 12","categories":[],"tags":[]},{"title":"1.1-学业数据初探","slug":"1-1-学业数据初探","date":"2019-05-23T07:46:45.000Z","updated":"2019-05-23T08:00:29.503Z","comments":true,"path":"2019/05/23/1-1-学业数据初探/","link":"","permalink":"http://yoursite.com/2019/05/23/1-1-学业数据初探/","excerpt":"","text":"学生数据集初探导入学生数据集 123import pandas as pdstudent_data_origin=pd.read_csv('student_data_origin.csv', index_col=0) 显示数据集的前5行 1student_data_origin.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScore09WhiteMALE19794617043BlackMALE19814728797HISPANICFEMALE19902533040BlackMALE19822841137WhiteMALE200178 显示数据集的列数与行数 1student_data_origin.shape (10875, 5) 查看数据集是否完整？是否含有缺失值？ 1student_data_origin.isnull().any() PID False childrace True childsex False birthyear False Score False dtype: bool 显示含有缺失值的行 1student_data_origin[student_data_origin.isnull().values==True] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScore741210732NaNMALE198132 整个数据集只有一行含有缺失值，那么最简单，最直接的处理方法就是删除这一行。之后的课程会介绍如何填充这些缺失值 1student_data_origin.dropna(axis=0, how='any', inplace=True) 再次查看是否含有缺失值？ 1student_data_origin.isnull().any() PID False childrace False childsex False birthyear False Score False dtype: bool 随堂练习 1导入母亲数据集(mom_data_origin.csv)并显示前5行 123456# grader format### BEGIN SOLUTIONmom_data_v2 = pd.read_csv('mom_data_origin.csv', index_col=0)mom_data_v2.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 20140115106.05HISPANICIn Active ForcesNORTHEASTSeparated7192012Employed56329.0NORTHEASTSeparated1215105.05HISPANICUnemployedNORTHEASTSeparated6726512Employed51346.0NORTHEASTSeparated23669.05HISPANICOut of LaborNORTHEASTNever Married2623451Unemployed45465.0WESTNever Married3407.05BlackOut of LaborNORTHEASTSeparated555351Out of Labor8284.0WESTSeparated451270.05BlackIn Active ForcesNORTHEASTSeparated4288451Unemployed45088.0WESTSeparated 随堂练习 2查看母亲数据集中是否含有缺失值 12345# grader format### BEGIN SOLUTIONmom_data_v2.isnull().any()### END SOLUTION PID False HIGHEST GRADE COMPLETED False TOTAL IQ SCORE True SAMPLE IDENTIFICATION CODE False RACIAL False EMPLOYMENT STATUS 1979 False REGION 1979 False MARITAL STATUS 1979 False TOTAL NET FAMILY INCOME 1979 False AFQT False EMPLOYMENT STATUS 2014 False TOTAL NET FAMILY INCOME 2014 True REGION 2014 False MARITAL STATUS 2014 False dtype: bool 随堂练习 3显示母亲数据集中，含有缺失值的行 12345# grader format### BEGIN SOLUTIONmom_data_v2[mom_data_v2.isnull().values==True]### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201471761770.06WhiteIn Active ForcesNORTHEASTSeparated4934936UnemployedNaNNORTHEASTMarried7277657.06HISPANICUnemployedNORTHEASTDivorced3349236UnemployedNaNNORTHEASTSeparated7378992.05HISPANICEmployedNORTHEASTMarried3507060EmployedNaNNORTHEASTSeparated74791592.05BlackIn Active ForcesNORTHEASTSeparated5139960EmployedNaNNORTHEASTMarried75801086.06WhiteIn Active ForcesNORTHEASTWidowed5096072Out of LaborNaNNORTHEASTSeparated768119143.06WhiteEmployedNORTHEASTMarried4732672EmployedNaNNORTHEASTMarried778219145.06WhiteEmployedNORTHEASTMarried7551772In Active ForcesNaNNORTHEASTMarried7983684.05BlackUnemployedNORTHEASTDivorced2514863Out of LaborNaNNORTHEASTDivorced808419122.05HISPANICEmployedNORTHEASTMarried6238863EmployedNaNNORTHEASTSeparated8185584.05BlackIn Active ForcesNORTHEASTSeparated3404435UnemployedNaNNORTHEASTWidowed828611116.05HISPANICIn Active ForcesNORTHEASTSeparated3885535UnemployedNaNNORTHEASTDivorced8387056.05BlackOut of LaborNORTHEASTSeparated1554535EmployedNaNNORTHEASTSeparated848818103.05WhiteEmployedNORTHEASTDivorced6155340EmployedNaNNORTHEASTSeparated858919132.05WhiteIn Active ForcesNORTHEASTMarried7125633EmployedNaNNORTHEASTMarried869018112.05HISPANICIn Active ForcesNORTHEASTSeparated6073833In Active ForcesNaNNORTHEASTSeparated8791443.05HISPANICIn Active ForcesNORTHEASTSeparated1471033In Active ForcesNaNNORTHEASTNever Married889318113.05HISPANICIn Active ForcesNORTH CENTRALMarried5317028In Active ForcesNaNNORTHEASTMarried89941263.05HISPANICOut of LaborNORTHEASTNever Married3164931UnemployedNaNWESTSeparated9610013NaN5BlackEmployedNORTHEASTNever Married4348889In Active Forces49307.0NORTHEASTMarried971011NaN5BlackOut of LaborNORTHEASTNever Married2009949Out of Labor2170.0NORTHEASTSeparated9810212NaN5BlackEmployedNORTHEASTDivorced5265289In Active Forces62060.0NORTHEASTDivorced10010317NaN5BlackEmployedNORTHEASTMarried6593089In Active Forces64084.0NORTHEASTMarried20921813NaN5BlackIn Active ForcesNORTHEASTDivorced4705698In Active Forces56407.0NORTHEASTDivorced21021915NaN5BlackIn Active ForcesNORTHEASTDivorced6356998Employed77272.0NORTHEASTMarried2512576NaN5BlackOut of LaborNORTHEASTSeparated2880219Unemployed41629.0NORTHEASTMarried2522582NaN5BlackOut of LaborNORTHEASTDivorced290619Out of Labor24760.0NORTHEASTDivorced2532590NaN5BlackOut of LaborNORTHEASTSeparated437219Out of Labor17699.0NORTHEASTSeparated2722794NaN5BlackUnemployedNORTHEASTSeparated2933742Unemployed35401.0NORTHEASTWidowed3093139NaN5BlackOut of LaborNORTHEASTDivorced4042759Employed33049.0SOUTHWidowed 通过随堂练习3，我们可以发现母亲数据集中含有比较多的缺失值，集中在TOTAL IQ SCORE和TOTAL NET FAMILY INCOME 2014两列中，因此直接删除整行并不合适，因此我们需要填充这些缺失值。这里我们选择用整列的平均数来填充这些缺失值。首先，我们先提取TOTAL NET FAMILY INCOME 2014列的数据。 12income_2014 = mom_data_v2[ 'TOTAL NET FAMILY INCOME 2014' ]income_2014[0:3] 0 56329.0 1 51346.0 2 45465.0 Name: TOTAL NET FAMILY INCOME 2014, dtype: float64 计算income_2014的平均数 1234import numpy as npincome_2014_mean = np.mean(income_2014)print(income_2014_mean) 45113.1124246035 用平均数来填充2014年收入列的缺失值 12mom_data_v2[ 'TOTAL NET FAMILY INCOME 2014' ] = \\mom_data_v2[ 'TOTAL NET FAMILY INCOME 2014' ].fillna(income_2014_mean) 再次查看表格中的缺失值 1mom_data_v2[mom_data_v2.isnull().values==True] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 20149610013NaN5BlackEmployedNORTHEASTNever Married4348889In Active Forces49307.0NORTHEASTMarried971011NaN5BlackOut of LaborNORTHEASTNever Married2009949Out of Labor2170.0NORTHEASTSeparated9810212NaN5BlackEmployedNORTHEASTDivorced5265289In Active Forces62060.0NORTHEASTDivorced10010317NaN5BlackEmployedNORTHEASTMarried6593089In Active Forces64084.0NORTHEASTMarried20921813NaN5BlackIn Active ForcesNORTHEASTDivorced4705698In Active Forces56407.0NORTHEASTDivorced21021915NaN5BlackIn Active ForcesNORTHEASTDivorced6356998Employed77272.0NORTHEASTMarried2512576NaN5BlackOut of LaborNORTHEASTSeparated2880219Unemployed41629.0NORTHEASTMarried2522582NaN5BlackOut of LaborNORTHEASTDivorced290619Out of Labor24760.0NORTHEASTDivorced2532590NaN5BlackOut of LaborNORTHEASTSeparated437219Out of Labor17699.0NORTHEASTSeparated2722794NaN5BlackUnemployedNORTHEASTSeparated2933742Unemployed35401.0NORTHEASTWidowed3093139NaN5BlackOut of LaborNORTHEASTDivorced4042759Employed33049.0SOUTHWidowed 保存修改后的数据集，命名为mom_data_wNaN.csv 1mom_data_v2.to_csv('mom_data_wNaN.csv') 随堂练习 4提取mom_data_v2中的Total IQ SCORE列的数据 12345# grader format### BEGIN SOLUTIONiq = mom_data_v2[ 'TOTAL IQ SCORE' ]### END SOLUTION 随堂练习 5计算Total IQ SCORE列的平均数,并打印出平均数 123456# grader format### BEGIN SOLUTIONiq_mean = np.mean(iq)print(iq_mean)### END SOLUTION 85.31447587674062 随堂练习 6以IQ的平均数来替换mom_data_v2的Total IQ SCORE列的缺失值。 12345# grader format### BEGIN SOLUTIONmom_data_v2[ 'TOTAL IQ SCORE'] = mom_data_v2[ 'TOTAL IQ SCORE'].fillna(iq_mean)### END SOLUTION 数据集合并学生数据集和母亲数据集并不是每行一一对应的，而是通过PID连接在一起的，因此我们需要通过PID来合并两个数据集。 12df1=pd.DataFrame(&#123;'key':['a','b','c'],'data1':range(3)&#125;)print(df1) key data1 0 a 0 1 b 1 2 c 2 12df2=pd.DataFrame(&#123;'key':['a','b','c'],'data2':range(10,13)&#125;)print(df2) key data2 0 a 10 1 b 11 2 c 12 12df_1_2 = pd.merge(df1,df2,on='key')print(df_1_2) key data1 data2 0 a 0 10 1 b 1 11 2 c 2 12 12df3=pd.DataFrame(&#123;'key':['a','a','b','b','c','c'],'data1':range(6)&#125;)print(df3) key data1 0 a 0 1 a 1 2 b 2 3 b 3 4 c 4 5 c 5 12df4=pd.DataFrame(&#123;'key':['a','b','d'],'data2':range(3)&#125;)print(df4) key data2 0 a 0 1 b 1 2 d 2 12df_3_4 = pd.merge(df3,df4,on='key')print(df_3_4) key data1 data2 0 a 0 0 1 a 1 0 2 b 2 1 3 b 3 1 随堂练习 7通过PID合并学生数据集(student_data_origin)以及母亲数据集(mom_data)，将合并后的数据集命名为student_mom_data 123456# grader format### BEGIN SOLUTIONstudent_mom_data = pd.merge(student_data_origin,mom_data_v2,on='PID')student_mom_data.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201409WhiteMALE197946989.06WhiteEmployedNORTHEASTDivorced4556743Unemployed41220.0NORTHEASTSeparated17043BlackMALE198147475.013WhiteUnemployedNORTH CENTRALNever Married2095978Unemployed40202.0NORTH CENTRALNever Married28797HISPANICFEMALE199025328.014BlackUnemployedWESTNever Married509829Unemployed21774.0WESTWidowed33040BlackMALE19822813113.07WhiteEmployedNORTHEASTMarried5781214Out of Labor60610.0NORTHEASTMarried41137WhiteMALE2001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarried 从数据集中提取对应行或者列提取对应列比如’Score’以及’TOTAL IQ SCORE’ 1student_mom_data[['Score', 'TOTAL IQ SCORE']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }ScoreTOTAL IQ SCORE04689.014775.022528.0328113.047880.053963.0690140.074797.0883101.0970115.01052104.011641.0125775.01391129.0143417.01558104.01658108.01750109.0184341.019684.0207495.02171123.02251120.0236087.02485114.02598114.0265482.02754104.02864102.0292972.0………108444879.0108452889.01084636.0108475069.01084860101.01084973110.01085088147.0108511827.01085257115.0108534293.0108542189.0108551847.01085675104.010857338.0108583643.01085992128.01086086125.01086180103.0108621111.01086396114.0108647791.01086583115.0108664394.0108675692.0108687298.0108691219.01087038.0108714234.0108722489.01087378113.010874 rows × 2 columns 提取对应行 1student_mom_data.loc[0:5,:] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScoreHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 201409WhiteMALE197946989.06WhiteEmployedNORTHEASTDivorced4556743Unemployed41220.0NORTHEASTSeparated17043BlackMALE198147475.013WhiteUnemployedNORTH CENTRALNever Married2095978Unemployed40202.0NORTH CENTRALNever Married28797HISPANICFEMALE199025328.014BlackUnemployedWESTNever Married509829Unemployed21774.0WESTWidowed33040BlackMALE19822813113.07WhiteEmployedNORTHEASTMarried5781214Out of Labor60610.0NORTHEASTMarried41137WhiteMALE2001781580.05WhiteEmployedSOUTHSeparated6408227In Active Forces47115.0SOUTHMarried58798HISPANICMALE199139463.014HISPANICUnemployedWESTDivorced3459729Unemployed35566.0WESTDivorced 1student_mom_data.loc[0:5,['childrace','TOTAL IQ SCORE']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }childraceTOTAL IQ SCORE0White89.01Black75.02HISPANIC28.03Black113.04White80.05HISPANIC63.0 逻辑提取从学生数据集中提取提取childrace是white的数据 1white_data = student_data_origin[student_data_origin['childrace'] == 'White'] 1white_data.head(5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScore09WhiteMALE19794641137WhiteMALE20017863683WhiteFEMALE19909086388WhiteMALE198283114026WhiteFEMALE19916 计算white_data数据集中’Score’的平均数，极大值和极小值 1np.mean(white_data['Score']) 59.207518022657055 1np.max(white_data['Score']) 100 1np.min(white_data['Score']) 0 显示在白人孩子(white_data.csv)中Score达到98分的学生情况 1white_data[white_data['Score']==98] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScore253614WhiteFEMALE19909837111329WhiteMALE1988983938963WhiteMALE19819810233163WhiteFEMALE19859811194147WhiteMALE19809811241065WhiteMALE19999812997192WhiteFEMALE19819820422737WhiteMALE199798248610076WhiteMALE19909828603678WhiteFEMALE19949829783622WhiteFEMALE1986983139598WhiteMALE19859832065066WhiteFEMALE19849832578574WhiteMALE1985983385235WhiteFEMALE19909839154421WhiteMALE20009840961760WhiteFEMALE19879841598307WhiteFEMALE198598541210821WhiteMALE198398624410079WhiteFEMALE19859863937982WhiteFEMALE19779864513696WhiteFEMALE1991986591387WhiteMALE199698673011137WhiteFEMALE1979987009557WhiteMALE19879870849332WhiteFEMALE19889874835156WhiteMALE199998782610643WhiteFEMALE198198800411380WhiteFEMALE198798861911337WhiteMALE197998870210214WhiteFEMALE198298914210907WhiteFEMALE19959894604008WhiteFEMALE198498967411145WhiteFEMALE198598101814051WhiteMALE197898102111877WhiteMALE19839810274922WhiteMALE2002981037511255WhiteFEMALE198598104141428WhiteMALE198298104699249WhiteFEMALE198398105586384WhiteMALE198198 获得白人小孩分数在98分同时是95年后出生的数据 1white_data[(white_data['Score']==98) &amp; (white_data['birthyear'] &gt; 1995)] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScore11241065WhiteMALE19999820422737WhiteMALE19979839154421WhiteMALE2000986591387WhiteMALE19969874835156WhiteMALE19999810274922WhiteMALE200298 随堂练习 8从学生数据集(student_data_origin)中提取种族为西班牙裔(‘HISPANIC’)的学生，并展示前5行。 123456# grader format### BEGIN SOLUTIONhispanic_data = student_data_origin[student_data_origin['childrace'] == 'HISPANIC']hispanic_data.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDchildracechildsexbirthyearScore28797HISPANICFEMALE19902558798HISPANICMALE199139158581HISPANICMALE198958298136HISPANICMALE199029355478HISPANICMALE198264 随堂练习 9西班牙裔学生中，最年轻的学生是哪一年出生的并打印该年份 123456# grader format### BEGIN SOLUTIONyear = np.max(hispanic_data['birthyear'])print(year)### END SOLUTION 2009 随堂练习 10在hispanic_data数据集中提取在上题中年份出生的西班牙裔学生数据 12345# grader format### BEGIN SOLUTIONprint(hispanic_data[hispanic_data['birthyear']==2009])### END SOLUTION PID childrace childsex birthyear Score 268 8761 HISPANIC MALE 2009 77 3714 8762 HISPANIC FEMALE 2009 40 课后练习 1导入之前保存的mom_data_wNaN.csv数据集并显示前5行 123456# grader format### BEGIN SOLUTIONmom_data_wNaN=pd.read_csv('mom_data_wNaN.csv', index_col=0)mom_data_wNaN.head(5)### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 20140115106.05HISPANICIn Active ForcesNORTHEASTSeparated7192012Employed56329.0NORTHEASTSeparated1215105.05HISPANICUnemployedNORTHEASTSeparated6726512Employed51346.0NORTHEASTSeparated23669.05HISPANICOut of LaborNORTHEASTNever Married2623451Unemployed45465.0WESTNever Married3407.05BlackOut of LaborNORTHEASTSeparated555351Out of Labor8284.0WESTSeparated451270.05BlackIn Active ForcesNORTHEASTSeparated4288451Unemployed45088.0WESTSeparated 课后练习 2显示mom_data_wNaN中含有缺失值的行 12345# grader format### BEGIN SOLUTIONmom_data_wNaN[mom_data_wNaN.isnull().values==True]### END SOLUTION .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }PIDHIGHEST GRADE COMPLETEDTOTAL IQ SCORESAMPLE IDENTIFICATION CODERACIALEMPLOYMENT STATUS 1979REGION 1979MARITAL STATUS 1979TOTAL NET FAMILY INCOME 1979AFQTEMPLOYMENT STATUS 2014TOTAL NET FAMILY INCOME 2014REGION 2014MARITAL STATUS 20149610013NaN5BlackEmployedNORTHEASTNever Married4348889In Active Forces49307.0NORTHEASTMarried971011NaN5BlackOut of LaborNORTHEASTNever Married2009949Out of Labor2170.0NORTHEASTSeparated9810212NaN5BlackEmployedNORTHEASTDivorced5265289In Active Forces62060.0NORTHEASTDivorced10010317NaN5BlackEmployedNORTHEASTMarried6593089In Active Forces64084.0NORTHEASTMarried20921813NaN5BlackIn Active ForcesNORTHEASTDivorced4705698In Active Forces56407.0NORTHEASTDivorced21021915NaN5BlackIn Active ForcesNORTHEASTDivorced6356998Employed77272.0NORTHEASTMarried2512576NaN5BlackOut of LaborNORTHEASTSeparated2880219Unemployed41629.0NORTHEASTMarried2522582NaN5BlackOut of LaborNORTHEASTDivorced290619Out of Labor24760.0NORTHEASTDivorced2532590NaN5BlackOut of LaborNORTHEASTSeparated437219Out of Labor17699.0NORTHEASTSeparated2722794NaN5BlackUnemployedNORTHEASTSeparated2933742Unemployed35401.0NORTHEASTWidowed3093139NaN5BlackOut of LaborNORTHEASTDivorced4042759Employed33049.0SOUTHWidowed 课后练习 3打印数据集mom_data_wNaN中RACIAL为Black的平均智商分数(TOTAL IQ SCORE) 123456# grader format### BEGIN SOLUTIONblack_avg_iq = np.mean(mom_data_wNaN[mom_data_wNaN['RACIAL'] == 'Black']['TOTAL IQ SCORE'])print(black_avg_iq)### END SOLUTION 59.82520929476317 课后练习 4以black_avg_iq的值来填充mom_data_wNaN中的缺失值 12345# grader format### BEGIN SOLUTIONmom_data_wNaN[ 'TOTAL IQ SCORE'] = mom_data_wNaN[ 'TOTAL IQ SCORE'].fillna(black_avg_iq)### END SOLUTION 课后练习 5通过PID将mom_data_wNaN与student_data_origin合并，命名为student_mom_revised,并保存为student_mom_revised.csv 123456# grader format### BEGIN SOLUTIONstudent_mom_revised = pd.merge(student_data_origin,mom_data_v2,on='PID')student_mom_revised.to_csv('student_mom_revised.csv')### END SOLUTION 12","categories":[],"tags":[]}]}